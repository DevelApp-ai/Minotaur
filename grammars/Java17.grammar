Grammar: Java17
TokenSplitter: Space
FormatType: EBNF

/*
 * Java 17 Grammar Specification (Java SE 17 LTS)
 * 
 * This grammar is designed for parsing the Java 17 programming language and is suitable for a grammar marketplace.
 * It covers the full language specification, including modern features like records, sealed classes, pattern matching,
 * text blocks, and switch expressions. This grammar is based on the official Java SE 17 specification.
 */

TokenSplitter: Space
Keywords: abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while, var, yield, record, sealed, permits, non-sealed

<compilation-unit> ::= <package-declaration>? <import-declarations>? <type-declarations>?

<package-declaration> ::= <annotations>? package <package-name> ;

<import-declarations> ::= <import-declaration>+

<import-declaration> ::= <single-type-import-declaration> | <type-import-on-demand-declaration> | <single-static-import-declaration> | <static-import-on-demand-declaration>

<single-type-import-declaration> ::= import <type-name> ;

<type-import-on-demand-declaration> ::= import <package-name> . * ;

<single-static-import-declaration> ::= import static <type-name> . <identifier> ;

<static-import-on-demand-declaration> ::= import static <type-name> . * ;

<type-declarations> ::= <type-declaration>+

<type-declaration> ::= <class-declaration> | <interface-declaration> | <record-declaration> | <enum-declaration> | <annotation-type-declaration> | ;

<class-declaration> ::= <normal-class-declaration> | <enum-declaration>

<normal-class-declaration> ::= <class-modifiers>? class <identifier> <type-parameters>? <superclass>? <superinterfaces>? <class-body>

<class-modifiers> ::= <class-modifier>+

<class-modifier> ::= <annotation> | public | protected | private | abstract | static | final | sealed | non-sealed | strictfp

<type-parameters> ::= < <type-parameter-list> >

<type-parameter-list> ::= <type-parameter> | <type-parameter-list> , <type-parameter>

<superclass> ::= extends <class-type>

<superinterfaces> ::= implements <interface-type-list>

<interface-type-list> ::= <interface-type> | <interface-type-list> , <interface-type>

<class-body> ::= { <class-body-declarations>? }

<class-body-declarations> ::= <class-body-declaration>+

<class-body-declaration> ::= <class-member-declaration> | <instance-initializer> | <static-initializer> | <constructor-declaration>

<class-member-declaration> ::= <field-declaration> | <method-declaration> | <class-declaration> | <interface-declaration> | <record-declaration> | ;

<field-declaration> ::= <field-modifiers>? <unann-type> <variable-declarator-list> ;

<field-modifiers> ::= <field-modifier>+

<field-modifier> ::= <annotation> | public | protected | private | static | final | transient | volatile

<variable-declarator-list> ::= <variable-declarator> | <variable-declarator-list> , <variable-declarator>

<variable-declarator> ::= <variable-declarator-id> | <variable-declarator-id> = <variable-initializer>

<variable-declarator-id> ::= <identifier> <dims>?

<variable-initializer> ::= <expression> | <array-initializer>

<unann-type> ::= <unann-primitive-type> | <unann-reference-type>

<unann-primitive-type> ::= <numeric-type> | boolean

<numeric-type> ::= <integral-type> | <floating-point-type>

<integral-type> ::= byte | short | int | long | char

<floating-point-type> ::= float | double

<unann-reference-type> ::= <unann-class-or-interface-type> | <unann-type-variable> | <unann-array-type>

<unann-class-or-interface-type> ::= <unann-class-type> | <unann-interface-type>

<unann-class-type> ::= <identifier> <type-arguments>? | <package-name> . <annotations>? <identifier> <type-arguments>? | <unann-class-or-interface-type> . <annotations>? <identifier> <type-arguments>?

<unann-interface-type> ::= <unann-class-type>

<unann-type-variable> ::= <identifier>

<unann-array-type> ::= <unann-primitive-type> <dims> | <unann-class-or-interface-type> <dims> | <unann-type-variable> <dims>

<method-declaration> ::= <method-modifiers>? <method-header> <method-body>

<method-modifiers> ::= <method-modifier>+

<method-modifier> ::= <annotation> | public | protected | private | abstract | static | final | synchronized | native | strictfp

<method-header> ::= <result> <method-declarator> <throws>? | <type-parameters> <annotations>? <result> <method-declarator> <throws>?

<result> ::= <unann-type> | void

<method-declarator> ::= <identifier> ( <formal-parameter-list>? ) <dims>?

<formal-parameter-list> ::= <formal-parameter> | <formal-parameter-list> , <formal-parameter>

<formal-parameter> ::= <variable-modifier>* <unann-type> <variable-declarator-id> | <variable-arity-parameter>

<variable-arity-parameter> ::= <variable-modifier>* <unann-type> <annotations>? ... <identifier>

<variable-modifier> ::= <annotation> | final

<throws> ::= throws <exception-type-list>

<exception-type-list> ::= <exception-type> | <exception-type-list> , <exception-type>

<exception-type> ::= <class-type> | <type-variable>

<method-body> ::= <block> | ;

<instance-initializer> ::= <block>

<static-initializer> ::= static <block>

<constructor-declaration> ::= <constructor-modifiers>? <constructor-declarator> <throws>? <constructor-body>

<constructor-modifiers> ::= <constructor-modifier>+

<constructor-modifier> ::= <annotation> | public | protected | private

<constructor-declarator> ::= <type-parameters>? <simple-type-name> ( <formal-parameter-list>? )

<simple-type-name> ::= <identifier>

<constructor-body> ::= { <explicit-constructor-invocation>? <block-statements>? }

<explicit-constructor-invocation> ::= <type-arguments>? this ( <argument-list>? ) ; | <type-arguments>? super ( <argument-list>? ) ; | <expression-name> . <type-arguments>? super ( <argument-list>? ) ; | <primary> . <type-arguments>? super ( <argument-list>? ) ;

<enum-declaration> ::= <class-modifiers>? enum <identifier> <superinterfaces>? <enum-body>

<enum-body> ::= { <enum-constant-list>? ,? <enum-body-declarations>? }

<enum-constant-list> ::= <enum-constant> | <enum-constant-list> , <enum-constant>

<enum-constant> ::= <enum-constant-modifiers>? <identifier> ( <argument-list>? )? <class-body>?

<enum-constant-modifiers> ::= <enum-constant-modifier>+

<enum-constant-modifier> ::= <annotation>

<enum-body-declarations> ::= ; <class-body-declarations>?

<record-declaration> ::= <class-modifiers>? record <identifier> <type-parameters>? <record-header> <superinterfaces>? <record-body>

<record-header> ::= ( <record-component-list>? )

<record-component-list> ::= <record-component> | <record-component-list> , <record-component>

<record-component> ::= <record-component-modifier>* <unann-type> <identifier> | <record-component-modifier>* <unann-type> <annotations>? ... <identifier>

<record-component-modifier> ::= <annotation>

<record-body> ::= { <record-body-declaration>* }

<record-body-declaration> ::= <class-body-declaration> | <compact-constructor-declaration>

<compact-constructor-declaration> ::= <constructor-modifiers>? <simple-type-name> <constructor-body>

<interface-declaration> ::= <normal-interface-declaration> | <annotation-type-declaration>

<normal-interface-declaration> ::= <interface-modifiers>? interface <identifier> <type-parameters>? <extends-interfaces>? <permits>? <interface-body>

<interface-modifiers> ::= <interface-modifier>+

<interface-modifier> ::= <annotation> | public | protected | private | abstract | static | sealed | non-sealed | strictfp

<extends-interfaces> ::= extends <interface-type-list>

<permits> ::= permits <type-name-list>

<type-name-list> ::= <type-name> | <type-name-list> , <type-name>

<interface-body> ::= { <interface-member-declaration>* }

<interface-member-declaration> ::= <constant-declaration> | <interface-method-declaration> | <class-declaration> | <interface-declaration> | <record-declaration> | ;

<constant-declaration> ::= <constant-modifiers>? <unann-type> <variable-declarator-list> ;

<constant-modifiers> ::= <constant-modifier>+

<constant-modifier> ::= <annotation> | public | static | final

<interface-method-declaration> ::= <interface-method-modifiers>? <method-header> <method-body>

<interface-method-modifiers> ::= <interface-method-modifier>+

<interface-method-modifier> ::= <annotation> | public | private | abstract | default | static | strictfp

<annotation-type-declaration> ::= <interface-modifiers>? @ interface <identifier> <annotation-type-body>

<annotation-type-body> ::= { <annotation-type-member-declaration>* }

<annotation-type-member-declaration> ::= <annotation-type-element-declaration> | <constant-declaration> | <class-declaration> | <interface-declaration> | <record-declaration> | ;

<annotation-type-element-declaration> ::= <annotation-type-element-modifiers>? <unann-type> <identifier> ( ) <dims>? <default-value>? ;

<annotation-type-element-modifiers> ::= <annotation-type-element-modifier>+

<annotation-type-element-modifier> ::= <annotation> | public | abstract

<default-value> ::= default <element-value>

<annotations> ::= <annotation>+

<annotation> ::= <normal-annotation> | <marker-annotation> | <single-element-annotation>

<normal-annotation> ::= @ <type-name> ( <element-value-pair-list>? )

<element-value-pair-list> ::= <element-value-pair> | <element-value-pair-list> , <element-value-pair>

<element-value-pair> ::= <identifier> = <element-value>

<element-value> ::= <conditional-expression> | <element-value-array-initializer> | <annotation>

<element-value-array-initializer> ::= { <element-value-list>? ,? }

<element-value-list> ::= <element-value> | <element-value-list> , <element-value>

<marker-annotation> ::= @ <type-name>

<single-element-annotation> ::= @ <type-name> ( <element-value> )

<array-initializer> ::= { <variable-initializer-list>? ,? }

<variable-initializer-list> ::= <variable-initializer> | <variable-initializer-list> , <variable-initializer>

<block> ::= { <block-statements>? }

<block-statements> ::= <block-statement>+

<block-statement> ::= <local-variable-declaration-statement> | <local-class-declaration> | <local-interface-declaration> | <statement>

<local-variable-declaration-statement> ::= <local-variable-declaration> ;

<local-variable-declaration> ::= <variable-modifier>* <local-variable-type> <variable-declarator-list>

<local-variable-type> ::= <unann-type> | var

<local-class-declaration> ::= <class-modifiers>? class <identifier> <type-parameters>? <superclass>? <superinterfaces>? <class-body>

<local-interface-declaration> ::= <interface-modifiers>? interface <identifier> <type-parameters>? <extends-interfaces>? <interface-body>

<statement> ::= <statement-without-trailing-substatement> | <labeled-statement> | <if-then-statement> | <if-then-else-statement> | <while-statement> | <for-statement>

<statement-without-trailing-substatement> ::= <block> | <empty-statement> | <expression-statement> | <assert-statement> | <switch-statement> | <do-statement> | <break-statement> | <continue-statement> | <return-statement> | <synchronized-statement> | <throw-statement> | <try-statement> | <yield-statement>

<empty-statement> ::= ;

<labeled-statement> ::= <identifier> : <statement>

<expression-statement> ::= <statement-expression> ;

<statement-expression> ::= <assignment> | <pre-increment-expression> | <pre-decrement-expression> | <post-increment-expression> | <post-decrement-expression> | <method-invocation> | <class-instance-creation-expression>

<if-then-statement> ::= if ( <expression> ) <statement>

<if-then-else-statement> ::= if ( <expression> ) <statement-no-short-if> else <statement>

<assert-statement> ::= assert <expression> ; | assert <expression> : <expression> ;

<switch-statement> ::= switch ( <expression> ) <switch-block>

<switch-block> ::= { <switch-rule>* } | { <switch-block-statement-group>* <switch-label>* }

<switch-rule> ::= <switch-label> -> <expression> ; | <switch-label> -> <block> | <switch-label> -> <throw-statement>

<switch-block-statement-group> ::= <switch-label>+ <block-statements>

<switch-label> ::= case <case-constant> | case <pattern> | default

<case-constant> ::= <conditional-expression>

<pattern> ::= <type-pattern>

<type-pattern> ::= <local-variable-declaration>

<while-statement> ::= while ( <expression> ) <statement>

<do-statement> ::= do <statement> while ( <expression> ) ;

<for-statement> ::= <basic-for-statement> | <enhanced-for-statement>

<basic-for-statement> ::= for ( <for-init>? ; <expression>? ; <for-update>? ) <statement>

<for-init> ::= <statement-expression-list> | <local-variable-declaration>

<for-update> ::= <statement-expression-list>

<statement-expression-list> ::= <statement-expression> | <statement-expression-list> , <statement-expression>

<enhanced-for-statement> ::= for ( <local-variable-declaration> : <expression> ) <statement>

<break-statement> ::= break <identifier>? ;

<continue-statement> ::= continue <identifier>? ;

<return-statement> ::= return <expression>? ;

<throw-statement> ::= throw <expression> ;

<synchronized-statement> ::= synchronized ( <expression> ) <block>

<try-statement> ::= try <block> <catches> | try <block> <catches>? <finally> | <try-with-resources-statement>

<catches> ::= <catch-clause>+

<catch-clause> ::= catch ( <catch-formal-parameter> ) <block>

<catch-formal-parameter> ::= <variable-modifier>* <catch-type> <variable-declarator-id>

<catch-type> ::= <unann-class-type> | <catch-type> | <unann-class-type>

<finally> ::= finally <block>

<try-with-resources-statement> ::= try <resource-specification> <block> <catches>? <finally>?

<resource-specification> ::= ( <resource-list> ;? )

<resource-list> ::= <resource> | <resource-list> ; <resource>

<resource> ::= <local-variable-declaration> | <variable-access>

<variable-access> ::= <expression-name> | <field-access>

<yield-statement> ::= yield <expression> ;

<primary> ::= <primary-no-new-array> | <array-creation-expression>

<primary-no-new-array> ::= <literal> | <class-literal> | this | <type-name> . this | ( <expression> ) | <class-instance-creation-expression> | <field-access> | <array-access> | <method-invocation> | <method-reference>

<class-literal> ::= <type-name> . class | <numeric-type> . class | boolean . class | void . class

<class-instance-creation-expression> ::= <unqualified-class-instance-creation-expression> | <expression-name> . <unqualified-class-instance-creation-expression> | <primary> . <unqualified-class-instance-creation-expression>

<unqualified-class-instance-creation-expression> ::= new <type-arguments>? <class-or-interface-type-to-instantiate> ( <argument-list>? ) <class-body>?

<class-or-interface-type-to-instantiate> ::= <annotations>? <identifier> <type-arguments-or-diamond>? | <class-or-interface-type-to-instantiate> . <annotations>? <identifier> <type-arguments-or-diamond>?

<type-arguments-or-diamond> ::= <type-arguments> | <>

<field-access> ::= <primary> . <identifier> | super . <identifier> | <type-name> . super . <identifier>

<array-access> ::= <expression-name> [ <expression> ] | <primary-no-new-array> [ <expression> ]

<method-invocation> ::= <method-name> ( <argument-list>? ) | <type-name> . <type-arguments>? <identifier> ( <argument-list>? ) | <expression-name> . <type-arguments>? <identifier> ( <argument-list>? ) | <primary> . <type-arguments>? <identifier> ( <argument-list>? ) | super . <type-arguments>? <identifier> ( <argument-list>? ) | <type-name> . super . <type-arguments>? <identifier> ( <argument-list>? )

<argument-list> ::= <expression> | <argument-list> , <expression>

<method-reference> ::= <expression-name> :: <type-arguments>? <identifier> | <primary> :: <type-arguments>? <identifier> | <reference-type> :: <type-arguments>? <identifier> | super :: <type-arguments>? <identifier> | <type-name> . super :: <type-arguments>? <identifier> | <class-type> :: <type-arguments>? new | <array-type> :: new

<array-creation-expression> ::= new <primitive-type> <dim-exprs> <dims>? | new <class-or-interface-type> <dim-exprs> <dims>? | new <primitive-type> <dims> <array-initializer> | new <class-or-interface-type> <dims> <array-initializer>

<dim-exprs> ::= <dim-expr>+

<dim-expr> ::= <annotations>? [ <expression> ]

<expression> ::= <lambda-expression> | <assignment-expression>

<lambda-expression> ::= <lambda-parameters> -> <lambda-body>

<lambda-parameters> ::= ( <lambda-parameter-list>? ) | <identifier>

<lambda-parameter-list> ::= <lambda-parameter> | <lambda-parameter-list> , <lambda-parameter>

<lambda-parameter> ::= <variable-modifier>* <lambda-parameter-type> <variable-declarator-id> | <identifier>

<lambda-parameter-type> ::= <unann-type> | var

<lambda-body> ::= <expression> | <block>

<assignment-expression> ::= <conditional-expression> | <assignment>

<assignment> ::= <left-hand-side> <assignment-operator> <expression>

<left-hand-side> ::= <expression-name> | <field-access> | <array-access>

<assignment-operator> ::= = | *= | /= | %= | += | -= | <<= | >>= | >>>= | &= | ^= | |=

<conditional-expression> ::= <conditional-or-expression> | <conditional-or-expression> ? <expression> : <conditional-expression> | <conditional-or-expression> ? <expression> : <lambda-expression>

<conditional-or-expression> ::= <conditional-and-expression> | <conditional-or-expression> || <conditional-and-expression>

<conditional-and-expression> ::= <inclusive-or-expression> | <conditional-and-expression> && <inclusive-or-expression>

<inclusive-or-expression> ::= <exclusive-or-expression> | <inclusive-or-expression> | <exclusive-or-expression>

<exclusive-or-expression> ::= <and-expression> | <exclusive-or-expression> ^ <and-expression>

<and-expression> ::= <equality-expression> | <and-expression> & <equality-expression>

<equality-expression> ::= <relational-expression> | <equality-expression> == <relational-expression> | <equality-expression> != <relational-expression>

<relational-expression> ::= <shift-expression> | <relational-expression> < <shift-expression> | <relational-expression> > <shift-expression> | <relational-expression> <= <shift-expression> | <relational-expression> >= <shift-expression> | <relational-expression> instanceof <reference-type> | <relational-expression> instanceof <pattern>

<shift-expression> ::= <additive-expression> | <shift-expression> << <additive-expression> | <shift-expression> >> <additive-expression> | <shift-expression> >>> <additive-expression>

<additive-expression> ::= <multiplicative-expression> | <additive-expression> + <multiplicative-expression> | <additive-expression> - <multiplicative-expression>

<multiplicative-expression> ::= <unary-expression> | <multiplicative-expression> * <unary-expression> | <multiplicative-expression> / <unary-expression> | <multiplicative-expression> % <unary-expression>

<unary-expression> ::= <pre-increment-expression> | <pre-decrement-expression> | + <unary-expression> | - <unary-expression> | <unary-expression-not-plus-minus>

<pre-increment-expression> ::= ++ <unary-expression>

<pre-decrement-expression> ::= -- <unary-expression>

<unary-expression-not-plus-minus> ::= <postfix-expression> | ~ <unary-expression> | ! <unary-expression> | <cast-expression> | <switch-expression>

<postfix-expression> ::= <primary> | <expression-name> | <post-increment-expression> | <post-decrement-expression>

<post-increment-expression> ::= <postfix-expression> ++

<post-decrement-expression> ::= <postfix-expression> --

<cast-expression> ::= ( <primitive-type> ) <unary-expression> | ( <reference-type> <additional-bound>* ) <unary-expression-not-plus-minus> | ( <reference-type> <additional-bound>* ) <lambda-expression>

<switch-expression> ::= switch ( <expression> ) <switch-block>

<constant-expression> ::= <expression>

<literal> ::= <integer-literal> | <floating-point-literal> | <boolean-literal> | <character-literal> | <string-literal> | <text-block> | <null-literal>

<text-block> ::= """ <text-block-characters> """

<text-block-characters> ::= <text-block-character>*

<text-block-character> ::= <input-character> | <escape-sequence>

<type> ::= <primitive-type> | <reference-type>

<primitive-type> ::= <annotations>? <numeric-type> | <annotations>? boolean

<reference-type> ::= <class-or-interface-type> | <type-variable> | <array-type>

<class-or-interface-type> ::= <class-type> | <interface-type>

<class-type> ::= <annotations>? <identifier> <type-arguments>? | <package-name> . <annotations>? <identifier> <type-arguments>? | <class-or-interface-type> . <annotations>? <identifier> <type-arguments>?

<interface-type> ::= <class-type>

<type-variable> ::= <annotations>? <identifier>

<array-type> ::= <primitive-type> <dims> | <class-or-interface-type> <dims> | <type-variable> <dims>

<dims> ::= <annotations>? [ ] | <dims> <annotations>? [ ]

<type-parameter> ::= <type-parameter-modifier>* <identifier> <type-bound>?

<type-parameter-modifier> ::= <annotation>

<type-bound> ::= extends <type-variable> | extends <class-or-interface-type> <additional-bound>*

<additional-bound> ::= & <interface-type>

<type-arguments> ::= < <type-argument-list> >

<type-argument-list> ::= <type-argument> | <type-argument-list> , <type-argument>

<type-argument> ::= <reference-type> | <wildcard>

<wildcard> ::= <annotations>? ? <wildcard-bounds>?

<wildcard-bounds> ::= extends <reference-type> | super <reference-type>

<package-name> ::= <identifier> | <package-name> . <identifier>

<type-name> ::= <identifier> | <package-name> . <identifier>

<expression-name> ::= <identifier> | <ambiguous-name> . <identifier>

<method-name> ::= <identifier> | <ambiguous-name> . <identifier>

<ambiguous-name> ::= <identifier> | <ambiguous-name> . <identifier>

<integer-literal> ::= <decimal-integer-literal> | <hex-integer-literal> | <octal-integer-literal> | <binary-integer-literal>

<decimal-integer-literal> ::= <decimal-numeral> <integer-type-suffix>?

<hex-integer-literal> ::= <hex-numeral> <integer-type-suffix>?

<octal-integer-literal> ::= <octal-numeral> <integer-type-suffix>?

<binary-integer-literal> ::= <binary-numeral> <integer-type-suffix>?

<integer-type-suffix> ::= l | L

<decimal-numeral> ::= 0 | <non-zero-digit> <digits>? | <non-zero-digit> <underscores> <digits>

<digits> ::= <digit> | <digit> <digits-and-underscores>? <digit>

<digit> ::= 0 | <non-zero-digit>

<non-zero-digit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<digits-and-underscores> ::= <digit-or-underscore>+

<digit-or-underscore> ::= <digit> | _

<underscores> ::= _+

<hex-numeral> ::= 0 x <hex-digits> | 0 X <hex-digits>

<hex-digits> ::= <hex-digit> | <hex-digit> <hex-digits-and-underscores>? <hex-digit>

<hex-digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F

<hex-digits-and-underscores> ::= <hex-digit-or-underscore>+

<hex-digit-or-underscore> ::= <hex-digit> | _

<octal-numeral> ::= 0 <octal-digits> | 0 <underscores> <octal-digits>

<octal-digits> ::= <octal-digit> | <octal-digit> <octal-digits-and-underscores>? <octal-digit>

<octal-digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7

<octal-digits-and-underscores> ::= <octal-digit-or-underscore>+

<octal-digit-or-underscore> ::= <octal-digit> | _

<binary-numeral> ::= 0 b <binary-digits> | 0 B <binary-digits>

<binary-digits> ::= <binary-digit> | <binary-digit> <binary-digits-and-underscores>? <binary-digit>

<binary-digit> ::= 0 | 1

<binary-digits-and-underscores> ::= <binary-digit-or-underscore>+

<binary-digit-or-underscore> ::= <binary-digit> | _

<floating-point-literal> ::= <decimal-floating-point-literal> | <hexadecimal-floating-point-literal>

<decimal-floating-point-literal> ::= <digits> . <digits>? <exponent-part>? <float-type-suffix>? | . <digits> <exponent-part>? <float-type-suffix>? | <digits> <exponent-part> <float-type-suffix>? | <digits> <exponent-part>? <float-type-suffix>

<exponent-part> ::= <exponent-indicator> <signed-integer>

<exponent-indicator> ::= e | E

<signed-integer> ::= <sign>? <digits>

<sign> ::= + | -

<float-type-suffix> ::= f | F | d | D

<hexadecimal-floating-point-literal> ::= <hex-significand> <binary-exponent> <float-type-suffix>?

<hex-significand> ::= <hex-numeral> . ? | 0 x <hex-digits>? . <hex-digits> | 0 X <hex-digits>? . <hex-digits>

<binary-exponent> ::= <binary-exponent-indicator> <signed-integer>

<binary-exponent-indicator> ::= p | P

<boolean-literal> ::= true | false

<character-literal> ::= ' <single-character> ' | ' <escape-sequence> '

<single-character> ::= <input-character-except-quote-and-backslash>

<string-literal> ::= " <string-characters>? "

<string-characters> ::= <string-character>+

<string-character> ::= <input-character-except-quote-and-backslash> | <escape-sequence>

<escape-sequence> ::= \b | \t | \n | \f | \r | \" | \' | \\ | <octal-escape> | <unicode-escape>

<octal-escape> ::= \ <octal-digit> | \ <octal-digit> <octal-digit> | \ <zero-to-three> <octal-digit> <octal-digit>

<zero-to-three> ::= 0 | 1 | 2 | 3

<unicode-escape> ::= \u+ <hex-digit> <hex-digit> <hex-digit> <hex-digit>

<null-literal> ::= null

<identifier> ::= <identifier-chars> but not a <keyword> or <boolean-literal> or <null-literal>

<identifier-chars> ::= <java-letter> | <identifier-chars> <java-letter-or-digit>

<java-letter> ::= any Unicode character that is a "Java letter"

<java-letter-or-digit> ::= any Unicode character that is a "Java letter-or-digit"

<statement-no-short-if> ::= <statement-without-trailing-substatement> | <labeled-statement-no-short-if> | <if-then-else-statement-no-short-if> | <while-statement-no-short-if> | <for-statement-no-short-if>

<labeled-statement-no-short-if> ::= <identifier> : <statement-no-short-if>

<if-then-else-statement-no-short-if> ::= if ( <expression> ) <statement-no-short-if> else <statement-no-short-if>

<while-statement-no-short-if> ::= while ( <expression> ) <statement-no-short-if>

<for-statement-no-short-if> ::= <basic-for-statement-no-short-if> | <enhanced-for-statement-no-short-if>

<basic-for-statement-no-short-if> ::= for ( <for-init>? ; <expression>? ; <for-update>? ) <statement-no-short-if>

<enhanced-for-statement-no-short-if> ::= for ( <local-variable-declaration> : <expression> ) <statement-no-short-if>

