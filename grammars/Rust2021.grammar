/*
 * Rust 2021 Grammar Specification
 * 
 * This grammar is designed for parsing the Rust 2021 edition programming language and is suitable for a grammar marketplace.
 * It covers the full language specification, including ownership, lifetimes, traits, generics, const generics, async/await,
 * macros, pattern matching, and all modern Rust features up to the 2021 edition. This grammar is based on the 
 * official Rust Language Reference and includes all language features available in Rust 1.56.0 and later.
 */

Grammar: CEBNF
TokenSplitter: Space
Keywords: as, async, await, break, const, continue, crate, dyn, else, enum, extern, false, fn, for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super, trait, true, type, union, unsafe, use, where, while, abstract, become, box, do, final, macro, override, priv, typeof, unsized, virtual, yield, try, catch

<crate> ::= <inner-attribute>* <item>*

/* Items */
<item> ::= <outer-attribute>* <visibility>? <item-kind>

<item-kind> ::= <module>
              | <extern-crate>
              | <use-declaration>
              | <function>
              | <type-alias>
              | <struct>
              | <enumeration>
              | <union>
              | <constant-item>
              | <static-item>
              | <trait>
              | <implementation>
              | <extern-block>
              | <macro-invocation-semi>
              | <macro-rules-definition>

<visibility> ::= pub
               | pub ( crate )
               | pub ( self )
               | pub ( super )
               | pub ( in <simple-path> )

/* Modules */
<module> ::= unsafe? mod <identifier> ;
           | unsafe? mod <identifier> { <inner-attribute>* <item>* }

/* Extern Crates */
<extern-crate> ::= extern crate <crate-ref> <as-clause>? ;

<crate-ref> ::= <identifier>
              | self

<as-clause> ::= as <identifier>
              | as _

/* Use Declarations */
<use-declaration> ::= use <use-tree> ;

<use-tree> ::= <simple-path>? :: *
             | <simple-path>? :: { <use-tree-list>? }
             | <simple-path> <as-clause>?

<use-tree-list> ::= <use-tree> ( , <use-tree> )* ,?

<simple-path> ::= ::? <simple-path-segment> ( :: <simple-path-segment> )*

<simple-path-segment> ::= <identifier>
                        | super
                        | self
                        | crate

/* Functions */
<function> ::= <function-qualifiers> fn <identifier> <generic-params>? ( <function-parameters>? ) <function-return-type>? <where-clause>? ( <block-expression> | ; )

<function-qualifiers> ::= const? async? unsafe? ( extern <abi>? )?

<abi> ::= <string-literal>
        | <raw-string-literal>

<function-parameters> ::= <self-param> ,?
                        | ( <self-param> , )? <function-param> ( , <function-param> )* ,?

<self-param> ::= <outer-attribute>* ( <shorthand-self> | <typed-self> )

<shorthand-self> ::= & <lifetime>? mut? self

<typed-self> ::= mut? self : <type>

<function-param> ::= <outer-attribute>* ( <function-param-pattern> | ... )

<function-param-pattern> ::= <pattern> : ( <type> | ... )

<function-return-type> ::= -> <type>

/* Type Aliases */
<type-alias> ::= type <identifier> <generic-params>? <where-clause>? = <type> ;

/* Structs */
<struct> ::= <struct-struct>
           | <tuple-struct>

<struct-struct> ::= struct <identifier> <generic-params>? <where-clause>? ( { <struct-fields>? } | ; )

<tuple-struct> ::= struct <identifier> <generic-params>? ( <tuple-fields>? ) <where-clause>? ;

<struct-fields> ::= <struct-field> ( , <struct-field> )* ,?

<struct-field> ::= <outer-attribute>* <visibility>? <identifier> : <type>

<tuple-fields> ::= <tuple-field> ( , <tuple-field> )* ,?

<tuple-field> ::= <outer-attribute>* <visibility>? <type>

/* Enumerations */
<enumeration> ::= enum <identifier> <generic-params>? <where-clause>? { <enum-items>? }

<enum-items> ::= <enum-item> ( , <enum-item> )* ,?

<enum-item> ::= <outer-attribute>* <visibility>? <identifier> ( <enum-item-tuple> | <enum-item-struct> )? <enum-item-discriminant>?

<enum-item-tuple> ::= ( <tuple-fields>? )

<enum-item-struct> ::= { <struct-fields>? }

<enum-item-discriminant> ::= = <expression>

/* Unions */
<union> ::= union <identifier> <generic-params>? <where-clause>? { <struct-fields> }

/* Constant Items */
<constant-item> ::= const ( <identifier> | _ ) : <type> ( = <expression> )? ;

/* Static Items */
<static-item> ::= static mut? <identifier> : <type> ( = <expression> )? ;

/* Traits */
<trait> ::= unsafe? trait <identifier> <generic-params>? ( : <type-param-bounds>? )? <where-clause>? { <inner-attribute>* <associated-item>* }

<associated-item> ::= <outer-attribute>* ( <macro-invocation-semi> | ( <visibility>? <associated-item-kind> ) )

<associated-item-kind> ::= <type-alias>
                         | <constant-item>
                         | <function>

/* Implementations */
<implementation> ::= <inherent-impl>
                   | <trait-impl>

<inherent-impl> ::= impl <generic-params>? <type> <where-clause>? { <inner-attribute>* <associated-item>* }

<trait-impl> ::= unsafe? impl <generic-params>? !? <type-path> for <type> <where-clause>? { <inner-attribute>* <associated-item>* }

/* External Blocks */
<extern-block> ::= unsafe? extern <abi>? { <inner-attribute>* <external-item>* }

<external-item> ::= <outer-attribute>* ( <macro-invocation-semi> | ( <visibility>? ( <static-item> | <function> ) ) )

/* Generic Parameters */
<generic-params> ::= < >
                   | < <generic-param> ( , <generic-param> )* ,? >

<generic-param> ::= <outer-attribute>* ( <lifetime-param> | <type-param> | <const-param> )

<lifetime-param> ::= <lifetime-or-label> ( : <lifetime-bounds> )?

<type-param> ::= <identifier> ( : <type-param-bounds>? )? ( = <type> )?

<const-param> ::= const <identifier> : <type> ( = <block-expression> | <identifier> | -? <literal-expression> )?

/* Where Clauses */
<where-clause> ::= where <where-clause-item> ( , <where-clause-item> )* ,?

<where-clause-item> ::= <lifetime-where-clause-item>
                      | <type-bound-where-clause-item>

<lifetime-where-clause-item> ::= <lifetime> : <lifetime-bounds>

<type-bound-where-clause-item> ::= <for-lifetimes>? <type> : <type-param-bounds>?

<for-lifetimes> ::= for < <lifetime-param> ( , <lifetime-param> )* ,? >

/* Type Parameter Bounds */
<type-param-bounds> ::= <type-param-bound> ( + <type-param-bound> )* +?

<type-param-bound> ::= <lifetime>
                     | <trait-bound>

<trait-bound> ::= ?? <for-lifetimes>? <type-path>

<lifetime-bounds> ::= ( <lifetime> + )* <lifetime>?

/* Types */
<type> ::= <type-no-bounds>
         | <impl-trait-type>
         | <trait-object-type>

<type-no-bounds> ::= <parenthesized-type>
                   | <impl-trait-type-one-bound>
                   | <trait-object-type-one-bound>
                   | <type-path>
                   | <tuple-type>
                   | <never-type>
                   | <raw-pointer-type>
                   | <reference-type>
                   | <array-type>
                   | <slice-type>
                   | <inferred-type>
                   | <qualified-path-in-type>
                   | <bare-function-type>
                   | <macro-invocation>

<parenthesized-type> ::= ( <type> )

<never-type> ::= !

<tuple-type> ::= ( )
               | ( ( <type> , )+ <type>? )

<array-type> ::= [ <type> ; <expression> ]

<slice-type> ::= [ <type> ]

<reference-type> ::= & <lifetime>? mut? <type-no-bounds>

<raw-pointer-type> ::= * ( mut | const ) <type-no-bounds>

<bare-function-type> ::= <for-lifetimes>? <function-type-qualifiers> fn ( <function-parameters-maybe-named-variadic>? ) <bare-function-return-type>?

<function-type-qualifiers> ::= unsafe? ( extern <abi>? )?

<function-parameters-maybe-named-variadic> ::= <maybe-named-function-parameters> | <maybe-named-function-parameters-variadic>

<maybe-named-function-parameters> ::= <maybe-named-param> ( , <maybe-named-param> )* ,?

<maybe-named-function-parameters-variadic> ::= ( <maybe-named-param> , )* <maybe-named-param> , ...

<maybe-named-param> ::= <outer-attribute>* ( ( <identifier> | _ ) : )? <type>

<bare-function-return-type> ::= -> <type-no-bounds>

<impl-trait-type> ::= impl <type-param-bounds>

<impl-trait-type-one-bound> ::= impl <trait-bound>

<trait-object-type> ::= dyn? <type-param-bounds>

<trait-object-type-one-bound> ::= dyn? <trait-bound>

<inferred-type> ::= _

/* Type Paths */
<type-path> ::= ::? <type-path-segment> ( :: <type-path-segment> )*

<type-path-segment> ::= <path-ident-segment> ( :: <generic-args> )?
                      | <path-ident-segment> ( :: <generic-args> )? <path-ident-segment>

<path-ident-segment> ::= <identifier>
                       | super
                       | self
                       | Self
                       | crate

<generic-args> ::= < >
                 | < <generic-arg> ( , <generic-arg> )* ,? >

<generic-arg> ::= <lifetime>
                | <type>
                | <generic-args-const>
                | <generic-args-binding>

<generic-args-const> ::= <block-expression>
                       | <literal-expression>
                       | - <literal-expression>
                       | <simple-path>

<generic-args-binding> ::= <identifier> = <type>

/* Qualified Paths */
<qualified-path-in-type> ::= <qualified-path-type> ( :: <type-path-segment> )+

<qualified-path-type> ::= < <type> ( as <type-path> )? >

/* Patterns */
<pattern> ::= <pattern-no-top-alt>
            | <pattern-no-top-alt> | <pattern>

<pattern-no-top-alt> ::= <pattern-without-range>
                       | <range-pattern>

<pattern-without-range> ::= <literal-pattern>
                          | <identifier-pattern>
                          | <wildcard-pattern>
                          | <rest-pattern>
                          | <reference-pattern>
                          | <struct-pattern>
                          | <tuple-struct-pattern>
                          | <tuple-pattern>
                          | <grouped-pattern>
                          | <slice-pattern>
                          | <path-pattern>
                          | <macro-invocation>

<literal-pattern> ::= true | false
                    | <char-literal>
                    | <byte-literal>
                    | <string-literal>
                    | <raw-string-literal>
                    | <byte-string-literal>
                    | <raw-byte-string-literal>
                    | - <integer-literal>
                    | - <float-literal>
                    | <integer-literal>
                    | <float-literal>

<identifier-pattern> ::= ref? mut? <identifier> ( @ <pattern-no-top-alt> )?

<wildcard-pattern> ::= _

<rest-pattern> ::= ..

<range-pattern> ::= <range-pattern-bound> ..= <range-pattern-bound>
                  | <range-pattern-bound> .. <range-pattern-bound>
                  | <range-pattern-bound> ..

<range-pattern-bound> ::= <char-literal>
                        | <byte-literal>
                        | - <integer-literal>
                        | - <float-literal>
                        | <integer-literal>
                        | <float-literal>
                        | <path-expression>
                        | <qualified-path-expression>

<reference-pattern> ::= ( & | && ) mut? <pattern-without-range>

<struct-pattern> ::= <path-in-expression> { <struct-pattern-elements>? }

<struct-pattern-elements> ::= <struct-pattern-fields> ( , | , <struct-pattern-et-cetera> )?
                            | <struct-pattern-et-cetera>

<struct-pattern-fields> ::= <struct-pattern-field> ( , <struct-pattern-field> )*

<struct-pattern-field> ::= <outer-attribute>* <struct-pattern-field-kind>

<struct-pattern-field-kind> ::= <tuple-index> : <pattern>
                              | <identifier> : <pattern>
                              | ref? mut? <identifier>

<struct-pattern-et-cetera> ::= <outer-attribute>* ..

<tuple-struct-pattern> ::= <path-in-expression> ( <tuple-struct-items>? )

<tuple-struct-items> ::= <pattern> ( , <pattern> )* ,?

<tuple-pattern> ::= ( <tuple-pattern-items>? )

<tuple-pattern-items> ::= <pattern> ,
                        | <rest-pattern>
                        | <pattern> ( , <pattern> )+ ,?
                        | <pattern> ( , <pattern> )* , <rest-pattern> ( , <pattern> )*

<grouped-pattern> ::= ( <pattern> )

<slice-pattern> ::= [ <slice-pattern-items>? ]

<slice-pattern-items> ::= <pattern> ( , <pattern> )* ,?

<path-pattern> ::= <path-expression>
                 | <qualified-path-expression>

/* Expressions */
<expression> ::= <expression-without-block>
               | <expression-with-block>

<expression-without-block> ::= <outer-attribute>* <expression-without-block-kind>

<expression-without-block-kind> ::= <literal-expression>
                                  | <path-expression>
                                  | <operator-expression>
                                  | <grouped-expression>
                                  | <array-expression>
                                  | <await-expression>
                                  | <index-expression>
                                  | <tuple-expression>
                                  | <tuple-indexing-expression>
                                  | <struct-expression>
                                  | <call-expression>
                                  | <method-call-expression>
                                  | <field-expression>
                                  | <closure-expression>
                                  | <continue-expression>
                                  | <break-expression>
                                  | <range-expression>
                                  | <return-expression>
                                  | <macro-invocation>

<expression-with-block> ::= <outer-attribute>* <expression-with-block-kind>

<expression-with-block-kind> ::= <block-expression>
                               | <async-block-expression>
                               | <unsafe-block-expression>
                               | <loop-expression>
                               | <if-expression>
                               | <if-let-expression>
                               | <match-expression>

/* Literal Expressions */
<literal-expression> ::= <char-literal>
                       | <string-literal>
                       | <raw-string-literal>
                       | <byte-literal>
                       | <byte-string-literal>
                       | <raw-byte-string-literal>
                       | <integer-literal>
                       | <float-literal>
                       | true
                       | false

/* Path Expressions */
<path-expression> ::= <path-in-expression>
                    | <qualified-path-in-expression>

<path-in-expression> ::= ::? <path-expr-segment> ( :: <path-expr-segment> )*

<path-expr-segment> ::= <path-ident-segment> ( :: <generic-args> )?

<qualified-path-in-expression> ::= <qualified-path-type> ( :: <path-expr-segment> )+

/* Operator Expressions */
<operator-expression> ::= <borrow-expression>
                        | <dereference-expression>
                        | <error-propagation-expression>
                        | <negation-expression>
                        | <arithmetic-or-logical-expression>
                        | <comparison-expression>
                        | <lazy-boolean-expression>
                        | <type-cast-expression>
                        | <assignment-expression>
                        | <compound-assignment-expression>

<borrow-expression> ::= ( & | && ) mut? <expression>

<dereference-expression> ::= * <expression>

<error-propagation-expression> ::= <expression> ?

<negation-expression> ::= ( ! | - ) <expression>

<arithmetic-or-logical-expression> ::= <expression> ( + | - | * | / | % | & | | | ^ | << | >> ) <expression>

<comparison-expression> ::= <expression> ( == | != | > | < | >= | <= ) <expression>

<lazy-boolean-expression> ::= <expression> ( || | && ) <expression>

<type-cast-expression> ::= <expression> as <type-no-bounds>

<assignment-expression> ::= <expression> = <expression>

<compound-assignment-expression> ::= <expression> ( += | -= | *= | /= | %= | &= | |= | ^= | <<= | >>= ) <expression>

/* Grouped Expression */
<grouped-expression> ::= ( <inner-attribute>* <expression> )

/* Array Expression */
<array-expression> ::= [ <inner-attribute>* <array-elements>? ]

<array-elements> ::= <expression> ( , <expression> )* ,?
                   | <expression> ; <expression>

/* Await Expression */
<await-expression> ::= <expression> . await

/* Index Expression */
<index-expression> ::= <expression> [ <expression> ]

/* Tuple Expression */
<tuple-expression> ::= ( <inner-attribute>* <tuple-elements>? )

<tuple-elements> ::= ( <expression> , )+ <expression>?

/* Tuple Indexing Expression */
<tuple-indexing-expression> ::= <expression> . <tuple-index>

<tuple-index> ::= <integer-literal>

/* Struct Expression */
<struct-expression> ::= <struct-expr-struct>
                      | <struct-expr-tuple>
                      | <struct-expr-unit>

<struct-expr-struct> ::= <path-in-expression> { <inner-attribute>* ( <struct-expr-fields> | <struct-base> )? }

<struct-expr-fields> ::= <struct-expr-field> ( , <struct-expr-field> )* ( , <struct-base> | , )?

<struct-expr-field> ::= <outer-attribute>* ( <identifier> | ( <identifier> | <tuple-index> ) : <expression> )

<struct-base> ::= .. <expression>

<struct-expr-tuple> ::= <path-in-expression> ( <inner-attribute>* ( <expression> ( , <expression> )* ,? )? )

<struct-expr-unit> ::= <path-in-expression>

/* Call Expression */
<call-expression> ::= <expression> ( <inner-attribute>* <call-params>? )

<call-params> ::= <expression> ( , <expression> )* ,?

/* Method Call Expression */
<method-call-expression> ::= <expression> . <path-expr-segment> ( <inner-attribute>* <call-params>? )

/* Field Expression */
<field-expression> ::= <expression> . <identifier>

/* Closure Expression */
<closure-expression> ::= move? ( || | | <closure-parameters>? | ) ( <expression> | -> <type-no-bounds> <block-expression> )

<closure-parameters> ::= <closure-param> ( , <closure-param> )* ,?

<closure-param> ::= <outer-attribute>* <pattern> ( : <type> )?

/* Continue Expression */
<continue-expression> ::= continue <lifetime-or-label>?

/* Break Expression */
<break-expression> ::= break <lifetime-or-label>? <expression>?

/* Range Expression */
<range-expression> ::= <range-expr>
                     | <range-from-expr>
                     | <range-to-expr>
                     | <range-full-expr>
                     | <range-inclusive-expr>
                     | <range-to-inclusive-expr>

<range-expr> ::= <expression> .. <expression>

<range-from-expr> ::= <expression> ..

<range-to-expr> ::= .. <expression>

<range-full-expr> ::= ..

<range-inclusive-expr> ::= <expression> ..= <expression>

<range-to-inclusive-expr> ::= ..= <expression>

/* Return Expression */
<return-expression> ::= return <expression>?

/* Block Expression */
<block-expression> ::= { <inner-attribute>* <statements>? }

<statements> ::= <statement>+ <expression>?
               | <expression>

<statement> ::= ;
              | <item>
              | <let-statement>
              | <expression-statement>
              | <macro-invocation-semi>

<let-statement> ::= <outer-attribute>* let <pattern> ( : <type> )? ( = <expression> ( else <block-expression> )? )? ;

<expression-statement> ::= <expression-without-block> ;
                         | <expression-with-block> ;?

/* Async Block Expression */
<async-block-expression> ::= async move? <block-expression>

/* Unsafe Block Expression */
<unsafe-block-expression> ::= unsafe <block-expression>

/* Loop Expression */
<loop-expression> ::= <loop-label>? ( <infinite-loop-expression> | <predicate-loop-expression> | <predicate-pattern-loop-expression> | <iterator-loop-expression> )

<infinite-loop-expression> ::= loop <block-expression>

<predicate-loop-expression> ::= while <expression> <block-expression>

<predicate-pattern-loop-expression> ::= while let <pattern> = <expression> <block-expression>

<iterator-loop-expression> ::= for <pattern> in <expression> <block-expression>

<loop-label> ::= <lifetime-or-label> :

/* If Expression */
<if-expression> ::= if <expression> <block-expression> ( else ( <block-expression> | <if-expression> | <if-let-expression> ) )?

/* If Let Expression */
<if-let-expression> ::= if let <pattern> = <expression> <block-expression> ( else ( <block-expression> | <if-expression> | <if-let-expression> ) )?

/* Match Expression */
<match-expression> ::= match <expression> { <inner-attribute>* <match-arms>? }

<match-arms> ::= ( <match-arm> => <match-arm-body> ,? )* <match-arm> => <match-arm-body> ,?

<match-arm> ::= <outer-attribute>* <match-arm-patterns> <match-arm-guard>?

<match-arm-patterns> ::= |? <pattern> ( | <pattern> )*

<match-arm-guard> ::= if <expression>

<match-arm-body> ::= <expression>
                   | <expression-with-block>

/* Attributes */
<inner-attribute> ::= # ! [ <attr> ]

<outer-attribute> ::= # [ <attr> ]

<attr> ::= <simple-path> <attr-input>?

<attr-input> ::= <delim-token-tree>
               | = <expression>

/* Tokens and Literals */
<delim-token-tree> ::= ( <token-tree>* )
                     | [ <token-tree>* ]
                     | { <token-tree>* }

<token-tree> ::= <token-tree-token>
               | <delim-token-tree>

<token-tree-token> ::= <identifier>
                     | <keyword>
                     | <literal>
                     | <punctuation>
                     | <delimiter>

/* Lifetimes and Labels */
<lifetime-or-label> ::= ' <non-keyword-identifier>
                      | 'static
                      | '_

<lifetime> ::= <lifetime-or-label>

/* Macros */
<macro-invocation> ::= <simple-path> ! <delim-token-tree>

<macro-invocation-semi> ::= <simple-path> ! <delim-token-tree> ;
                          | <simple-path> ! ( <token-tree>* ) ;
                          | <simple-path> ! [ <token-tree>* ] ;

<macro-rules-definition> ::= macro_rules ! <identifier> <macro-rules-def>

<macro-rules-def> ::= ( <macro-rules> ) ;
                    | [ <macro-rules> ] ;
                    | { <macro-rules> }

<macro-rules> ::= <macro-rule> ( ; <macro-rule> )* ;?

<macro-rule> ::= <macro-matcher> => <macro-transcriber>

<macro-matcher> ::= ( <macro-match>* )
                  | [ <macro-match>* ]
                  | { <macro-match>* }

<macro-match> ::= <token-tree-token>
                | <macro-matcher>
                | $ <identifier> : <macro-frag-spec>
                | $ ( <macro-match>+ ) <macro-rep-sep>? <macro-rep-op>

<macro-frag-spec> ::= block | expr | ident | item | lifetime | literal | meta | pat | pat_param | path | stmt | tt | ty | vis

<macro-rep-sep> ::= <token-tree-token>

<macro-rep-op> ::= * | + | ?

<macro-transcriber> ::= <delim-token-tree>

/* Identifiers */
<identifier> ::= <non-keyword-identifier> | <raw-identifier>

<non-keyword-identifier> ::= XID_Start XID_Continue* | _ XID_Continue+

<raw-identifier> ::= r# <non-keyword-identifier>

/* Keywords */
<keyword> ::= <strict-keyword> | <reserved-keyword>

<strict-keyword> ::= as | async | await | break | const | continue | crate | dyn | else | enum | extern | false | fn | for | if | impl | in | let | loop | match | mod | move | mut | pub | ref | return | self | Self | static | struct | super | trait | true | type | union | unsafe | use | where | while

<reserved-keyword> ::= abstract | become | box | do | final | macro | override | priv | typeof | unsized | virtual | yield | try | catch

/* Literals */
<literal> ::= <char-literal>
            | <string-literal>
            | <raw-string-literal>
            | <byte-literal>
            | <byte-string-literal>
            | <raw-byte-string-literal>
            | <integer-literal>
            | <float-literal>
            | <boolean-literal>

<boolean-literal> ::= true | false

<char-literal> ::= ' ( <char-literal-char> | <quote-escape> | <ascii-escape> | <unicode-escape> ) '

<char-literal-char> ::= <any-char-except-quote-backslash-newline-return-tab>

<string-literal> ::= " ( <string-literal-char> | <quote-escape> | <ascii-escape> | <unicode-escape> | <string-continue> )* "

<string-literal-char> ::= <any-char-except-quote-backslash-isolated-cr>

<raw-string-literal> ::= r <raw-string-content>

<raw-string-content> ::= " <raw-string-literal-char>* " | # <raw-string-content> #

<raw-string-literal-char> ::= <any-char>

<byte-literal> ::= b' ( <byte-literal-char> | <byte-escape> ) '

<byte-literal-char> ::= <ascii-char-except-quote-backslash-newline-return-tab>

<byte-string-literal> ::= b" ( <byte-string-literal-char> | <byte-escape> | <string-continue> )* "

<byte-string-literal-char> ::= <ascii-char-except-quote-backslash-isolated-cr>

<raw-byte-string-literal> ::= br <raw-byte-string-content>

<raw-byte-string-content> ::= " <raw-byte-string-literal-char>* " | # <raw-byte-string-content> #

<raw-byte-string-literal-char> ::= <ascii-char>

<integer-literal> ::= <decimal-literal> <integer-suffix>?
                    | <bin-literal> <integer-suffix>?
                    | <oct-literal> <integer-suffix>?
                    | <hex-literal> <integer-suffix>?

<decimal-literal> ::= <decimal-digit> ( <decimal-digit> | _ )*

<bin-literal> ::= 0b ( <bin-digit> | _ )* <bin-digit> ( <bin-digit> | _ )*

<oct-literal> ::= 0o ( <oct-digit> | _ )* <oct-digit> ( <oct-digit> | _ )*

<hex-literal> ::= 0x ( <hex-digit> | _ )* <hex-digit> ( <hex-digit> | _ )*

<decimal-digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<bin-digit> ::= 0 | 1

<oct-digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7

<hex-digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F

<integer-suffix> ::= u8 | u16 | u32 | u64 | u128 | usize | i8 | i16 | i32 | i64 | i128 | isize

<float-literal> ::= <decimal-literal> . <decimal-literal> <float-exponent>? <float-suffix>?
                  | <decimal-literal> <float-exponent> <float-suffix>?
                  | <decimal-literal> <float-suffix>

<float-exponent> ::= ( e | E ) ( + | - )? <decimal-literal>

<float-suffix> ::= f32 | f64

/* Escape Sequences */
<quote-escape> ::= \' | \"

<ascii-escape> ::= \x <oct-digit> <hex-digit>
                 | \n | \r | \t | \\ | \0

<unicode-escape> ::= \u{ ( <hex-digit> _? )* <hex-digit> ( <hex-digit> _? )* }

<byte-escape> ::= \x <hex-digit> <hex-digit>
                | \n | \r | \t | \\ | \0 | \' | \"

<string-continue> ::= \ <newline>

/* Character Classes */
<any-char> ::= <unicode-scalar-value>

<any-char-except-quote-backslash-newline-return-tab> ::= <unicode-scalar-value-except-quote-backslash-newline-return-tab>

<any-char-except-quote-backslash-isolated-cr> ::= <unicode-scalar-value-except-quote-backslash-isolated-cr>

<ascii-char> ::= <ascii-character>

<ascii-char-except-quote-backslash-newline-return-tab> ::= <ascii-character-except-quote-backslash-newline-return-tab>

<ascii-char-except-quote-backslash-isolated-cr> ::= <ascii-character-except-quote-backslash-isolated-cr>

<unicode-scalar-value> ::= <any-unicode-scalar-value>

<unicode-scalar-value-except-quote-backslash-newline-return-tab> ::= <unicode-scalar-value-except-specific-chars>

<unicode-scalar-value-except-quote-backslash-isolated-cr> ::= <unicode-scalar-value-except-specific-chars>

<ascii-character> ::= <printable-ascii> | <whitespace-ascii>

<ascii-character-except-quote-backslash-newline-return-tab> ::= <printable-ascii-except-quote-backslash>

<ascii-character-except-quote-backslash-isolated-cr> ::= <printable-ascii-except-quote-backslash>

<printable-ascii> ::= <ascii-letter> | <ascii-digit> | <ascii-punctuation>

<printable-ascii-except-quote-backslash> ::= <ascii-letter> | <ascii-digit> | <ascii-punctuation-except-quote-backslash>

<ascii-letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z

<ascii-digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<ascii-punctuation> ::= ! | " | # | $ | % | & | ' | ( | ) | * | + | , | - | . | / | : | ; | < | = | > | ? | @ | [ | \ | ] | ^ | _ | ` | { | | | } | ~

<ascii-punctuation-except-quote-backslash> ::= ! | # | $ | % | & | ( | ) | * | + | , | - | . | / | : | ; | < | = | > | ? | @ | [ | ] | ^ | _ | ` | { | | | } | ~

<whitespace-ascii> ::= <space> | <tab> | <newline> | <carriage-return>

<space> ::= " "
<tab> ::= \t
<newline> ::= \n
<carriage-return> ::= \r

/* Punctuation and Delimiters */
<punctuation> ::= + | - | * | / | % | ^ | ! | & | | | && | || | << | >> | += | -= | *= | /= | %= | ^= | &= | |= | <<= | >>= | = | == | != | > | < | >= | <= | @ | _ | . | .. | ... | ..= | , | ; | : | :: | -> | => | # | $ | ?

<delimiter> ::= ( | ) | [ | ] | { | }

/* Comments */
<line-comment> ::= // <comment-text>* <newline>?

<block-comment> ::= /* <block-comment-body>* */

<block-comment-body> ::= <block-comment>
                       | <comment-text>

<comment-text> ::= <any-char-except-cr-lf-for-line-comment>
                 | <any-char-except-star-slash-for-block-comment>

<any-char-except-cr-lf-for-line-comment> ::= <unicode-scalar-value-except-cr-lf>

<any-char-except-star-slash-for-block-comment> ::= <unicode-scalar-value-except-star-slash>

<unicode-scalar-value-except-cr-lf> ::= <unicode-scalar-value-except-specific-chars>

<unicode-scalar-value-except-star-slash> ::= <unicode-scalar-value-except-specific-chars>

<unicode-scalar-value-except-specific-chars> ::= <unicode-character>

<any-unicode-scalar-value> ::= <unicode-character>

<unicode-character> ::= <printable-unicode> | <whitespace-unicode>

<printable-unicode> ::= <ascii-letter> | <ascii-digit> | <unicode-letter> | <unicode-digit> | <unicode-punctuation>

<whitespace-unicode> ::= <space> | <tab> | <newline> | <carriage-return> | <unicode-whitespace>

<unicode-letter> ::= <unicode-letter-character>

<unicode-digit> ::= <unicode-digit-character>

<unicode-punctuation> ::= <unicode-punctuation-character>

<unicode-whitespace> ::= <unicode-whitespace-character>

<unicode-letter-character> ::= <any-unicode-letter>

<unicode-digit-character> ::= <any-unicode-digit>

<unicode-punctuation-character> ::= <any-unicode-punctuation>

<unicode-whitespace-character> ::= <any-unicode-whitespace>

<any-unicode-letter> ::= <unicode-letter-class>

<any-unicode-digit> ::= <unicode-digit-class>

<any-unicode-punctuation> ::= <unicode-punctuation-class>

<any-unicode-whitespace> ::= <unicode-whitespace-class>

<unicode-letter-class> ::= <letter-character>

<unicode-digit-class> ::= <digit-character>

<unicode-punctuation-class> ::= <punctuation-character>

<unicode-whitespace-class> ::= <whitespace-character>

<letter-character> ::= <ascii-letter> | <extended-unicode-letter>

<digit-character> ::= <ascii-digit> | <extended-unicode-digit>

<punctuation-character> ::= <ascii-punctuation> | <extended-unicode-punctuation>

<whitespace-character> ::= <ascii-whitespace> | <extended-unicode-whitespace>

<ascii-whitespace> ::= <space> | <tab> | <newline> | <carriage-return>

<extended-unicode-letter> ::= <non-ascii-unicode-letter>

<extended-unicode-digit> ::= <non-ascii-unicode-digit>

<extended-unicode-punctuation> ::= <non-ascii-unicode-punctuation>

<extended-unicode-whitespace> ::= <non-ascii-unicode-whitespace>

<non-ascii-unicode-letter> ::= <unicode-letter-beyond-ascii>

<non-ascii-unicode-digit> ::= <unicode-digit-beyond-ascii>

<non-ascii-unicode-punctuation> ::= <unicode-punctuation-beyond-ascii>

<non-ascii-unicode-whitespace> ::= <unicode-whitespace-beyond-ascii>

<unicode-letter-beyond-ascii> ::= <extended-letter-character>

<unicode-digit-beyond-ascii> ::= <extended-digit-character>

<unicode-punctuation-beyond-ascii> ::= <extended-punctuation-character>

<unicode-whitespace-beyond-ascii> ::= <extended-whitespace-character>

<extended-letter-character> ::= <unicode-extended-letter>

<extended-digit-character> ::= <unicode-extended-digit>

<extended-punctuation-character> ::= <unicode-extended-punctuation>

<extended-whitespace-character> ::= <unicode-extended-whitespace>

<unicode-extended-letter> ::= <any-extended-unicode-letter>

<unicode-extended-digit> ::= <any-extended-unicode-digit>

<unicode-extended-punctuation> ::= <any-extended-unicode-punctuation>

<unicode-extended-whitespace> ::= <any-extended-unicode-whitespace>

<any-extended-unicode-letter> ::= <letter>

<any-extended-unicode-digit> ::= <digit>

<any-extended-unicode-punctuation> ::= <punctuation>

<any-extended-unicode-whitespace> ::= <whitespace>

<letter> ::= <ascii-letter>

<digit> ::= <ascii-digit>

<punctuation> ::= <ascii-punctuation>

<whitespace> ::= <ascii-whitespace>

