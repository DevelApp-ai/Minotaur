Grammar: Bison_Base
TokenSplitter: Space
Inheritable: true
FormatType: Bison
ImportSemantics: true
CoordinateTokens: true

// Bison Base Grammar Template
// This base grammar defines the fundamental parsing patterns and semantic behaviors
// for Bison parser generators within Minotaur's inheritance-based compiler-compiler support

// ============================================================================
// BISON DECLARATIONS SECTION
// ============================================================================

// Token declarations
<token-declaration> ::= "%token" <token-list> => {
  declareBisonTokens($1);
}

<token-list> ::= <token-spec> (<token-spec>)*
<token-spec> ::= <TOKEN_NAME> <token-value>?
<token-value> ::= <INTEGER>

// Type declarations for semantic values
<type-declaration> ::= "%type" "<" <type-name> ">" <symbol-list> => {
  declareSymbolTypes($1, $2);
}

<type-name> ::= <IDENTIFIER>
<symbol-list> ::= <symbol> (<symbol>)*
<symbol> ::= <TOKEN_NAME> | <rule-name>

// Union declaration for semantic value types
<union-declaration> ::= "%union" "{" <union-members> "}" => {
  declareSemanticValueUnion($1);
}

<union-members> ::= <union-member>*
<union-member> ::= <type-specifier> <member-name> ";"

// ============================================================================
// PRECEDENCE AND ASSOCIATIVITY DECLARATIONS
// ============================================================================

// Left associative operators
<left-assoc> ::= "%left" <precedence-tokens> => {
  setLeftAssociativity($1);
}

// Right associative operators  
<right-assoc> ::= "%right" <precedence-tokens> => {
  setRightAssociativity($1);
}

// Non-associative operators
<nonassoc> ::= "%nonassoc" <precedence-tokens> => {
  setNonAssociativity($1);
}

<precedence-tokens> ::= <precedence-token>+
<precedence-token> ::= <TOKEN_NAME> | <string-literal>

// Precedence declarations (higher line number = higher precedence)
<precedence-declaration> ::= <left-assoc> | <right-assoc> | <nonassoc>

// ============================================================================
// GRAMMAR RULES SECTION
// ============================================================================

// Bison grammar rule pattern
<bison-rule> ::= <rule-name> ":" <rule-alternatives> ";" => {
  createBisonRule($1, $2);
}

// Rule alternatives separated by |
<rule-alternatives> ::= <rule-alternative> ("|" <rule-alternative>)*

// Single rule alternative with optional action
<rule-alternative> ::= <rule-elements> <semantic-action>? <precedence-override>?

// Rule elements (symbols in the production)
<rule-elements> ::= <rule-element>*
<rule-element> ::= <symbol-reference>
                | <string-literal>
                | <error-token>

// Symbol references
<symbol-reference> ::= <rule-name> => {
  createNonTerminalReference($1);
}
                    | <TOKEN_NAME> => {
  createTerminalReference($1);
}

// Error token for error recovery
<error-token> ::= "error" => {
  createErrorToken();
}

// ============================================================================
// SEMANTIC ACTIONS
// ============================================================================

// Bison semantic action with $$ and $n syntax
<semantic-action> ::= "{" <action-statements> "}" => {
  executeBisonAction($1, getCurrentRuleContext());
}

<action-statements> ::= <action-statement>*
<action-statement> ::= <assignment-statement>
                    | <function-call>
                    | <control-statement>
                    | <c-code-line>

// Assignment to $$ (rule result)
<assignment-statement> ::= "$$" "=" <value-expression> ";" => {
  setRuleResult($1);
}

// Access to rule element values ($1, $2, etc.)
<value-expression> ::= <stack-reference>
                    | <function-call>
                    | <arithmetic-expression>
                    | <string-literal>
                    | <INTEGER>

<stack-reference> ::= "$" <INTEGER> => {
  getStackValue($1, getCurrentRuleContext());
}
                   | "$$" => {
  getCurrentRuleResult();
}

// ============================================================================
// ERROR RECOVERY PATTERNS
// ============================================================================

// Error productions for recovery
<error-production> ::= <rule-name> ":" "error" <recovery-tokens>? <semantic-action>? ";" => {
  createErrorRecoveryRule($1, $2, $3);
}

<recovery-tokens> ::= <recovery-token>+
<recovery-token> ::= <TOKEN_NAME> | <string-literal>

// Error recovery actions
<error-recovery-action> ::= "{" <error-handling-code> "}" => {
  executeErrorRecovery($1);
}

<error-handling-code> ::= <c-code-block>

// ============================================================================
// PRECEDENCE OVERRIDE
// ============================================================================

// %prec directive to override default precedence
<precedence-override> ::= "%prec" <precedence-token> => {
  overridePrecedence($1);
}

// ============================================================================
// START SYMBOL DECLARATION
// ============================================================================

<start-declaration> ::= "%start" <rule-name> => {
  setStartSymbol($1);
}

// ============================================================================
// BISON DIRECTIVES AND OPTIONS
// ============================================================================

// Parser generation options
<bison-option> ::= "%define" <option-name> <option-value> => {
  setBisonOption($1, $2);
}

<option-name> ::= <IDENTIFIER> ("." <IDENTIFIER>)*
<option-value> ::= <string-literal> | <IDENTIFIER> | <INTEGER>

// Location tracking
<location-directive> ::= "%locations" => {
  enableLocationTracking();
}

// Pure parser (reentrant)
<pure-parser> ::= "%pure-parser" => {
  enablePureParser();
}

// GLR parser
<glr-parser> ::= "%glr-parser" => {
  enableGLRParser();
}

// ============================================================================
// C CODE SECTIONS
// ============================================================================

// Prologue section (before parser)
<prologue-section> ::= "%{" <c-code-block> "%}" => {
  addPrologueCode($1);
}

// Epilogue section (after parser)
<epilogue-section> ::= "%%" <c-code-block> => {
  addEpilogueCode($1);
}

<c-code-block> ::= <c-code-line>*
<c-code-line> ::= /[^\n]*\n/ => {
  preserveCCode($1);
}

// ============================================================================
// SEMANTIC VALUE HANDLING
// ============================================================================

// Semantic value access patterns
<semantic-value-access> ::= <stack-reference> <member-access>?

<member-access> ::= "." <member-name> => {
  accessUnionMember($1);
}

<member-name> ::= <IDENTIFIER>

// Type casting for semantic values
<type-cast> ::= "<" <type-name> ">" <stack-reference> => {
  castSemanticValue($1, $2);
}

// ============================================================================
// BISON IDENTIFIERS AND LITERALS
// ============================================================================

// Bison naming conventions
<TOKEN_NAME> ::= /[A-Z][A-Z0-9_]*/ => {
  validateTokenName($1);
}

<rule-name> ::= /[a-z][a-z0-9_]*/ => {
  validateRuleName($1);
}

<IDENTIFIER> ::= /[a-zA-Z_][a-zA-Z0-9_]*/ => {
  createIdentifier($1);
}

<INTEGER> ::= /[0-9]+/ => {
  parseInt($1);
}

// String literals
<string-literal> ::= '"' <double-quoted-string> '"' => {
  createStringLiteral($1);
}
                  | "'" <single-quoted-string> "'" => {
  createCharLiteral($1);
}

<double-quoted-string> ::= /[^"\\]*(\\.[^"\\]*)*/ => {
  unescapeString($1);
}

<single-quoted-string> ::= /[^'\\]*(\\.[^'\\]*)*/ => {
  unescapeString($1);
}

// ============================================================================
// SEMANTIC ACTION TEMPLATES
// ============================================================================

// Template for handling Bison semantic actions
<bison-action-template> ::= "{" <c-code> "}" => {
  // Preserve Bison action execution context
  const context = {
    stackValues: getParserStack(),
    ruleResult: getCurrentRuleResult(),
    locationInfo: getCurrentLocation(),
    symbolTable: getSymbolTable(),
    errorState: getErrorState()
  };
  
  // Execute action with Bison semantics
  executeBisonAction($1, context);
}

// Template for stack value access
<stack-value-template> ::= "$" <INTEGER> => {
  // Access parser stack value with Bison semantics
  const stackIndex = $1;
  const stackValue = getStackValue(stackIndex);
  return stackValue;
}

// Template for result assignment
<result-assignment-template> ::= "$$" "=" <expression> => {
  // Set rule result with Bison semantics
  setRuleResult($2);
}

// ============================================================================
// PRECEDENCE INHERITANCE TEMPLATES
// ============================================================================

// Default Bison precedence relationships (lowest to highest)
Precedence: {
  // Precedence levels (higher number = higher precedence)
  Level1: { tokens: ["||"], associativity: "left", description: "Logical OR" }
  Level2: { tokens: ["&&"], associativity: "left", description: "Logical AND" }
  Level3: { tokens: ["|"], associativity: "left", description: "Bitwise OR" }
  Level4: { tokens: ["^"], associativity: "left", description: "Bitwise XOR" }
  Level5: { tokens: ["&"], associativity: "left", description: "Bitwise AND" }
  Level6: { tokens: ["==", "!="], associativity: "left", description: "Equality" }
  Level7: { tokens: ["<", ">", "<=", ">="], associativity: "left", description: "Relational" }
  Level8: { tokens: ["<<", ">>"], associativity: "left", description: "Shift" }
  Level9: { tokens: ["+", "-"], associativity: "left", description: "Additive" }
  Level10: { tokens: ["*", "/", "%"], associativity: "left", description: "Multiplicative" }
  Level11: { tokens: ["!"], associativity: "right", description: "Unary" }
}

// ============================================================================
// ERROR RECOVERY INHERITANCE TEMPLATES
// ============================================================================

// Bison error recovery strategies
ErrorRecovery: {
  strategy: "explicit",
  errorToken: true,
  errorProductions: true,
  synchronization: ["semicolon", "brace"],
  reportingLevel: "basic",
  
  // Error synchronization tokens
  syncTokens: [";", "}", "{"],
  
  // Recovery actions
  recoveryActions: {
    syntaxError: "errorProduction",
    parseError: "synchronize",
    lexicalError: "skipToken"
  },
  
  // Error reporting
  errorReporting: {
    format: "bison",
    includeLocation: true,
    includeContext: true
  }
}

// ============================================================================
// SHIFT/REDUCE CONFLICT RESOLUTION
// ============================================================================

// Conflict resolution templates
<conflict-resolution> ::= <shift-reduce-resolution>
                       | <reduce-reduce-resolution>

<shift-reduce-resolution> ::= "%expect" <INTEGER> => {
  expectShiftReduceConflicts($1);
}

<reduce-reduce-resolution> ::= "%expect-rr" <INTEGER> => {
  expectReduceReduceConflicts($1);
}

// ============================================================================
// EXTENSION POINTS FOR INHERITANCE
// ============================================================================

// Extension point for additional token declarations
<extended-tokens> ::= <token-declaration>* => {
  processExtendedTokens($1);
}

// Extension point for additional type declarations
<extended-types> ::= <type-declaration>* => {
  processExtendedTypes($1);
}

// Extension point for additional precedence declarations
<extended-precedence> ::= <precedence-declaration>* => {
  processExtendedPrecedence($1);
}

// Extension point for additional grammar rules
<extended-rules> ::= <bison-rule>* => {
  processExtendedRules($1);
}

// Extension point for custom semantic actions
<extended-actions> ::= <semantic-action>* => {
  processExtendedActions($1);
}

