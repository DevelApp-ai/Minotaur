/*
 * C++20 Grammar Specification (ISO/IEC 14882:2020)
 * 
 * This grammar is designed for parsing the C++20 programming language and is suitable for a grammar marketplace.
 * It covers the full language specification, including modern features like concepts, modules, coroutines, and ranges.
 * This grammar is based on the official ISO standard and is designed for use with modern parser generators.
 */

TokenSplitter: Space
Keywords: alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char8_t, char16_t, char32_t, class, compl, concept, const, consteval, constexpr, constinit, const_cast, continue, co_await, co_return, co_yield, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, requires, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq

<translation-unit> ::= <declaration-seq>?

<primary-expression> ::= <literal> | this | ( <expression> ) | <id-expression> | <lambda-expression> | <fold-expression> | <requires-expression>

<id-expression> ::= <unqualified-id> | <qualified-id>

<unqualified-id> ::= <identifier> | <operator-function-id> | <conversion-function-id> | <literal-operator-id> | ~ <class-name> | ~ <decltype-specifier> | <template-id>

<qualified-id> ::= <nested-name-specifier> template? <unqualified-id>

<nested-name-specifier> ::= :: | <type-name> :: | <namespace-name> :: | <decltype-specifier> :: | <nested-name-specifier> <identifier> :: | <nested-name-specifier> template? <simple-template-id> ::

<lambda-expression> ::= <lambda-introducer> <lambda-declarator>? <compound-statement>

<lambda-introducer> ::= [ <lambda-capture>? ]

<lambda-capture> ::= <capture-default> | <capture-list> | <capture-default> , <capture-list>

<capture-default> ::= & | =

<capture-list> ::= <capture> ...? | <capture-list> , <capture> ...?

<capture> ::= <simple-capture> | <init-capture>

<simple-capture> ::= <identifier> | & <identifier> | this | * this

<init-capture> ::= ...? <identifier> <initializer> | & ...? <identifier> <initializer>

<lambda-declarator> ::= ( <parameter-declaration-clause> ) decl-specifier-seq? noexcept-specifier? attribute-specifier-seq? -> <type-id> trailing-return-type?

<fold-expression> ::= ( <cast-expression> <fold-operator> ... ) | ( ... <fold-operator> <cast-expression> ) | ( <cast-expression> <fold-operator> ... <fold-operator> <cast-expression> )

<fold-operator> ::= + | - | * | / | % | ^ | & | | | = | < | > | << | >> | += | -= | *= | /= | %= | ^= | &= | |= | <<= | >>= | == | != | <= | >= | && | || | , | .* | ->*

<requires-expression> ::= requires ( <parameter-declaration-clause> )? { <requirement-seq> }

<requirement-seq> ::= <requirement>+

<requirement> ::= <simple-requirement> | <type-requirement> | <compound-requirement> | <nested-requirement>

<simple-requirement> ::= <expression> ;

<type-requirement> ::= typename <type-name> ;

<compound-requirement> ::= { <expression> } noexcept? -> <type-constraint> ;

<nested-requirement> ::= requires <constraint-expression> ;

<postfix-expression> ::= <primary-expression> | <postfix-expression> [ <expression> ] | <postfix-expression> ( <expression-list>? ) | <simple-type-specifier> ( <expression-list>? ) | <typename-specifier> ( <expression-list>? ) | <postfix-expression> . template? <id-expression> | <postfix-expression> -> template? <id-expression> | <postfix-expression> ++ | <postfix-expression> -- | dynamic_cast < <type-id> > ( <expression> ) | static_cast < <type-id> > ( <expression> ) | reinterpret_cast < <type-id> > ( <expression> ) | const_cast < <type-id> > ( <expression> ) | typeid ( <expression> ) | typeid ( <type-id> )

<expression-list> ::= <initializer-list>

<unary-expression> ::= <postfix-expression> | ++ <cast-expression> | -- <cast-expression> | <unary-operator> <cast-expression> | sizeof <unary-expression> | sizeof ( <type-id> ) | sizeof ... ( <identifier> ) | alignof ( <type-id> ) | <noexcept-expression> | <new-expression> | <delete-expression> | <co_await-expression>

<co_await-expression> ::= co_await <cast-expression>

<unary-operator> ::= * | & | + | - | ! | ~

<new-expression> ::= ::? new <new-placement>? <new-type-id> <new-initializer>? | ::? new <new-placement>? ( <type-id> ) <new-initializer>?

<new-placement> ::= ( <expression-list> )

<new-type-id> ::= <type-specifier-seq> <new-declarator>?

<new-declarator> ::= <ptr-operator> <new-declarator>? | <noptr-new-declarator>

<noptr-new-declarator> ::= [ <expression> ] attribute-specifier-seq? | <noptr-new-declarator> [ <constant-expression> ] attribute-specifier-seq?

<new-initializer> ::= ( <expression-list>? ) | <braced-init-list>

<delete-expression> ::= ::? delete <cast-expression> | ::? delete [ ] <cast-expression>

<noexcept-expression> ::= noexcept ( <expression> )

<cast-expression> ::= <unary-expression> | ( <type-id> ) <cast-expression>

<pm-expression> ::= <cast-expression> | <pm-expression> .* <cast-expression> | <pm-expression> ->* <cast-expression>

<multiplicative-expression> ::= <pm-expression> | <multiplicative-expression> * <pm-expression> | <multiplicative-expression> / <pm-expression> | <multiplicative-expression> % <pm-expression>

<additive-expression> ::= <multiplicative-expression> | <additive-expression> + <multiplicative-expression> | <additive-expression> - <multiplicative-expression>

<shift-expression> ::= <additive-expression> | <shift-expression> << <additive-expression> | <shift-expression> >> <additive-expression>

<compare-expression> ::= <shift-expression> | <compare-expression> < <shift-expression> | <compare-expression> > <shift-expression> | <compare-expression> <= <shift-expression> | <compare-expression> >= <shift-expression> | <compare-expression> <=> <shift-expression>

<relational-expression> ::= <compare-expression> | <relational-expression> == <compare-expression> | <relational-expression> != <compare-expression>

<equality-expression> ::= <relational-expression> | <equality-expression> == <relational-expression> | <equality-expression> != <relational-expression>

<and-expression> ::= <equality-expression> | <and-expression> & <equality-expression>

<exclusive-or-expression> ::= <and-expression> | <exclusive-or-expression> ^ <and-expression>

<inclusive-or-expression> ::= <exclusive-or-expression> | <inclusive-or-expression> | <exclusive-or-expression>

<logical-and-expression> ::= <inclusive-or-expression> | <logical-and-expression> && <inclusive-or-expression>

<logical-or-expression> ::= <logical-and-expression> | <logical-or-expression> || <logical-and-expression>

<conditional-expression> ::= <logical-or-expression> | <logical-or-expression> ? <expression> : <assignment-expression>

<yield-expression> ::= co_yield <assignment-expression> | co_yield <braced-init-list>

<assignment-expression> ::= <conditional-expression> | <logical-or-expression> <assignment-operator> <initializer-clause> | <throw-expression> | <yield-expression>

<assignment-operator> ::= = | *= | /= | %= | += | -= | >>= | <<= | &= | ^= | |=

<expression> ::= <assignment-expression> | <expression> , <assignment-expression>

<constant-expression> ::= <conditional-expression>

<statement> ::= <labeled-statement> | <attribute-specifier-seq>? <compound-statement> | <attribute-specifier-seq>? <selection-statement> | <attribute-specifier-seq>? <iteration-statement> | <attribute-specifier-seq>? <jump-statement> | <declaration-statement> | <attribute-specifier-seq>? <try-block> | <attribute-specifier-seq>? <coroutine-return-statement>

<labeled-statement> ::= <attribute-specifier-seq>? <identifier> : <statement> | <attribute-specifier-seq>? case <constant-expression> : <statement> | <attribute-specifier-seq>? default : <statement>

<compound-statement> ::= { <statement-seq>? }

<statement-seq> ::= <statement>+

<selection-statement> ::= if ( <init-statement>? <condition> ) <statement> | if ( <init-statement>? <condition> ) <statement> else <statement> | switch ( <init-statement>? <condition> ) <statement>

<condition> ::= <expression> | <attribute-specifier-seq>? <decl-specifier-seq> <declarator> = <initializer-clause> | <attribute-specifier-seq>? <decl-specifier-seq> <declarator> <braced-init-list>

<iteration-statement> ::= while ( <condition> ) <statement> | do <statement> while ( <expression> ) ; | for ( <init-statement> <condition>? ; <expression>? ) <statement> | for ( <for-range-declaration> : <for-range-initializer> ) <statement>

<init-statement> ::= <expression-statement> | <simple-declaration>

<for-range-declaration> ::= <attribute-specifier-seq>? <decl-specifier-seq> <declarator>

<for-range-initializer> ::= <expression> | <braced-init-list>

<jump-statement> ::= break ; | continue ; | return <expression>? ; | return <braced-init-list> ; | goto <identifier> ;

<coroutine-return-statement> ::= co_return <expression>? ; | co_return <braced-init-list> ;

<declaration-statement> ::= <block-declaration>

<block-declaration> ::= <simple-declaration> | <asm-definition> | <namespace-alias-definition> | <using-declaration> | <using-directive> | <static_assert-declaration> | <alias-declaration> | <opaque-enum-declaration>

<simple-declaration> ::= <decl-specifier-seq> <init-declarator-list>? ; | <attribute-specifier-seq> <decl-specifier-seq> <init-declarator-list> ; | <attribute-specifier-seq>? <decl-specifier-seq> <ref-qualifier>? [ <identifier-list> ] <initializer> ;

<static_assert-declaration> ::= static_assert ( <constant-expression> ) ; | static_assert ( <constant-expression> , <string-literal> ) ;

<empty-declaration> ::= ;

<attribute-declaration> ::= <attribute-specifier-seq> ;

<decl-specifier> ::= <storage-class-specifier> | <type-specifier> | <function-specifier> | friend | typedef | constexpr | consteval | constinit | inline

<decl-specifier-seq> ::= <decl-specifier> <attribute-specifier-seq>? | <decl-specifier> <decl-specifier-seq>

<storage-class-specifier> ::= static | thread_local | extern | mutable

<function-specifier> ::= virtual | explicit

<typedef-name> ::= <identifier>

<type-specifier> ::= <simple-type-specifier> | <elaborated-type-specifier> | <typename-specifier> | <cv-qualifier>

<type-specifier-seq> ::= <type-specifier> <attribute-specifier-seq>? | <type-specifier> <type-specifier-seq>

<elaborated-type-specifier> ::= <class-key> <attribute-specifier-seq>? <nested-name-specifier>? <identifier> | <class-key> <simple-template-id> | <class-key> <nested-name-specifier> template? <simple-template-id> | enum <nested-name-specifier>? <identifier>

<simple-type-specifier> ::= <nested-name-specifier>? <type-name> | <nested-name-specifier> template <simple-template-id> | char | char8_t | char16_t | char32_t | wchar_t | bool | short | int | long | signed | unsigned | float | double | void | <decltype-specifier>

<type-name> ::= <class-name> | <enum-name> | <typedef-name> | <simple-template-id>

<decltype-specifier> ::= decltype ( <expression> )

<cv-qualifier> ::= const | volatile

<init-declarator-list> ::= <init-declarator> | <init-declarator-list> , <init-declarator>

<init-declarator> ::= <declarator> <initializer>?

<declarator> ::= <ptr-declarator> | <noptr-declarator> <parameters-and-qualifiers> <trailing-return-type>

<ptr-declarator> ::= <noptr-declarator> | <ptr-operator> <ptr-declarator>

<noptr-declarator> ::= <declarator-id> <attribute-specifier-seq>? | <noptr-declarator> <parameters-and-qualifiers> | <noptr-declarator> [ <constant-expression>? ] <attribute-specifier-seq>? | ( <ptr-declarator> )

<parameters-and-qualifiers> ::= ( <parameter-declaration-clause> ) <cv-qualifier-seq>? <ref-qualifier>? <noexcept-specifier>? <attribute-specifier-seq>?

<trailing-return-type> ::= -> <type-id>

<ptr-operator> ::= * <attribute-specifier-seq>? <cv-qualifier-seq>? | & <attribute-specifier-seq>? | && <attribute-specifier-seq>? | <nested-name-specifier> * <attribute-specifier-seq>? <cv-qualifier-seq>?

<cv-qualifier-seq> ::= <cv-qualifier> <cv-qualifier-seq>?

<ref-qualifier> ::= & | &&

<declarator-id> ::= ...? <id-expression>

<type-id> ::= <type-specifier-seq> <abstract-declarator>?

<abstract-declarator> ::= <ptr-abstract-declarator> | <noptr-abstract-declarator>? <parameters-and-qualifiers> <trailing-return-type> | <abstract-pack-declarator>

<ptr-abstract-declarator> ::= <noptr-abstract-declarator> | <ptr-operator> <ptr-abstract-declarator>?

<noptr-abstract-declarator> ::= <noptr-abstract-declarator>? <parameters-and-qualifiers> | <noptr-abstract-declarator>? [ <constant-expression>? ] <attribute-specifier-seq>? | ( <ptr-abstract-declarator> )

<abstract-pack-declarator> ::= ...

<parameter-declaration-clause> ::= <parameter-declaration-list>? ...? | <parameter-declaration-list> , ...

<parameter-declaration-list> ::= <parameter-declaration> | <parameter-declaration-list> , <parameter-declaration>

<parameter-declaration> ::= <attribute-specifier-seq>? <decl-specifier-seq> <declarator> | <attribute-specifier-seq>? <decl-specifier-seq> <declarator> = <initializer-clause> | <attribute-specifier-seq>? <decl-specifier-seq> <abstract-declarator>? | <attribute-specifier-seq>? <decl-specifier-seq> <abstract-declarator>? = <initializer-clause>

<initializer> ::= <brace-or-equal-initializer> | ( <expression-list> )

<brace-or-equal-initializer> ::= = <initializer-clause> | <braced-init-list>

<initializer-clause> ::= <assignment-expression> | <braced-init-list>

<braced-init-list> ::= { <initializer-list> ,? } | { <designated-initializer-list> } | { }

<initializer-list> ::= <initializer-clause> ...? | <initializer-list> , <initializer-clause> ...?

<designated-initializer-list> ::= <designated-initializer> | <designated-initializer-list> , <designated-initializer>

<designated-initializer> ::= <designator> <brace-or-equal-initializer>

<designator> ::= . <identifier> | [ <constant-expression> ]

<class-specifier> ::= <class-head> { <member-specification>? }

<class-head> ::= <class-key> <attribute-specifier-seq>? <class-head-name> <class-virt-specifier>? <base-clause>? | <class-key> <attribute-specifier-seq>? <base-clause>?

<class-head-name> ::= <nested-name-specifier>? <class-name>

<class-virt-specifier> ::= final

<class-key> ::= class | struct | union

<member-specification> ::= <member-declaration> <member-specification>? | <access-specifier> : <member-specification>?

<member-declaration> ::= <attribute-specifier-seq>? <decl-specifier-seq>? <member-declarator-list>? ; | <function-definition> | <using-declaration> | <static_assert-declaration> | <template-declaration> | <alias-declaration> | <opaque-enum-declaration> | <empty-declaration>

<member-declarator-list> ::= <member-declarator> | <member-declarator-list> , <member-declarator>

<member-declarator> ::= <declarator> <virt-specifier-seq>? <pure-specifier>? | <declarator> <requires-clause>? | <identifier>? <attribute-specifier-seq>? : <constant-expression>

<virt-specifier-seq> ::= <virt-specifier>+

<virt-specifier> ::= override | final

<pure-specifier> ::= = 0

<base-clause> ::= : <base-specifier-list>

<base-specifier-list> ::= <base-specifier> ...? | <base-specifier-list> , <base-specifier> ...?

<base-specifier> ::= <attribute-specifier-seq>? <class-or-decltype> | <attribute-specifier-seq>? virtual <access-specifier>? <class-or-decltype> | <attribute-specifier-seq>? <access-specifier> virtual? <class-or-decltype>

<class-or-decltype> ::= <nested-name-specifier>? <class-name> | <decltype-specifier>

<access-specifier> ::= private | protected | public

<conversion-function-id> ::= operator <conversion-type-id>

<conversion-type-id> ::= <type-specifier-seq> <conversion-declarator>?

<conversion-declarator> ::= <ptr-operator> <conversion-declarator>?

<ctor-initializer> ::= : <mem-initializer-list>

<mem-initializer-list> ::= <mem-initializer> ...? | <mem-initializer> , <mem-initializer-list>

<mem-initializer> ::= <mem-initializer-id> ( <expression-list>? ) | <mem-initializer-id> <braced-init-list>

<mem-initializer-id> ::= <class-or-decltype> | <identifier>

<operator-function-id> ::= operator <operator>

<literal-operator-id> ::= operator "" <identifier>

<template-declaration> ::= template < <template-parameter-list> > <declaration> | template < <template-parameter-list> > <concept-definition>

<template-parameter-list> ::= <template-parameter> | <template-parameter-list> , <template-parameter>

<template-parameter> ::= <type-parameter> | <parameter-declaration>

<type-parameter> ::= <type-parameter-key> ...? <identifier>? | <type-parameter-key> <identifier>? = <type-id> | template < <template-parameter-list> > <type-parameter-key> ...? <identifier>? | template < <template-parameter-list> > <type-parameter-key> <identifier>? = <id-expression>

<type-parameter-key> ::= class | typename

<simple-template-id> ::= <template-name> < <template-argument-list>? >

<template-id> ::= <simple-template-id> | <operator-function-id> < <template-argument-list>? > | <literal-operator-id> < <template-argument-list>? >

<template-name> ::= <identifier>

<template-argument-list> ::= <template-argument> ...? | <template-argument-list> , <template-argument> ...?

<template-argument> ::= <constant-expression> | <type-id> | <id-expression>

<typename-specifier> ::= typename <nested-name-specifier> <identifier> | typename <nested-name-specifier> template? <simple-template-id>

<explicit-instantiation> ::= extern? template <declaration>

<explicit-specialization> ::= template < > <declaration>

<try-block> ::= try <compound-statement> <handler-seq>

<function-try-block> ::= try <ctor-initializer>? <compound-statement> <handler-seq>

<handler-seq> ::= <handler> <handler-seq>?

<handler> ::= catch ( <exception-declaration> ) <compound-statement>

<exception-declaration> ::= <attribute-specifier-seq>? <type-specifier-seq> <declarator> | <attribute-specifier-seq>? <type-specifier-seq> <abstract-declarator>? | ...

<throw-expression> ::= throw <assignment-expression>?

<noexcept-specifier> ::= noexcept ( <constant-expression> ) | noexcept

<concept-definition> ::= concept <identifier> = <constraint-expression> ;

<constraint-expression> ::= <logical-or-expression>

<requires-clause> ::= requires <constraint-expression>

<namespace-definition> ::= <named-namespace-definition> | <unnamed-namespace-definition> | <nested-namespace-definition>

<named-namespace-definition> ::= inline? namespace <identifier> { <namespace-body> }

<unnamed-namespace-definition> ::= inline? namespace { <namespace-body> }

<nested-namespace-definition> ::= namespace <enclosing-namespace-specifier> :: <identifier> { <namespace-body> }

<enclosing-namespace-specifier> ::= <identifier> | <enclosing-namespace-specifier> :: <identifier>

<namespace-body> ::= <declaration-seq>?

<namespace-alias-definition> ::= namespace <identifier> = <qualified-namespace-specifier> ;

<qualified-namespace-specifier> ::= <nested-name-specifier>? <namespace-name>

<using-declaration> ::= using typename? <nested-name-specifier> <unqualified-id> ; | using :: <unqualified-id> ;

<using-directive> ::= <attribute-specifier-seq>? using namespace <nested-name-specifier>? <namespace-name> ;

<asm-definition> ::= <attribute-specifier-seq>? asm ( <string-literal> ) ;

<linkage-specification> ::= extern <string-literal> { <declaration-seq>? } | extern <string-literal> <declaration>

<attribute-specifier-seq> ::= <attribute-specifier>+

<attribute-specifier> ::= [ [ <attribute-using-prefix>? <attribute-list> ] ]

<attribute-using-prefix> ::= using <attribute-namespace> :

<attribute-list> ::= <attribute> ...? | <attribute-list> , <attribute> ...?

<attribute> ::= <attribute-token> <attribute-argument-clause>?

<attribute-token> ::= <identifier> | <attribute-scoped-token>

<attribute-scoped-token> ::= <attribute-namespace> :: <identifier>

<attribute-namespace> ::= <identifier>

<attribute-argument-clause> ::= ( <balanced-token-seq> )

<balanced-token-seq> ::= <balanced-token>*

<balanced-token> ::= ( <balanced-token-seq> ) | [ <balanced-token-seq> ] | { <balanced-token-seq> } | <any-token-except-paren-bracket-brace>

<module-declaration> ::= export? module <module-name> <module-partition>? <attribute-specifier-seq>? ;

<module-name> ::= <module-name-qualifier>? <identifier>

<module-partition> ::= : <module-name>

<module-name-qualifier> ::= <identifier> . | <module-name-qualifier> <identifier> .

<export-declaration> ::= export <declaration> | export { <declaration-seq>? } | export <module-import-declaration>

<module-import-declaration> ::= import <module-name> <attribute-specifier-seq>? ; | import <module-partition> <attribute-specifier-seq>? ; | import <header-name> <attribute-specifier-seq>? ;

<preprocessor-token> ::= <header-name> | <identifier> | <pp-number> | <character-literal> | <user-defined-character-literal> | <string-literal> | <user-defined-string-literal> | <preprocessing-op-or-punc> | <each-non-white-space-character-that-cannot-be-one-of-the-above>

<preprocessing-file> ::= <group>?

<group> ::= <group-part>+

<group-part> ::= <if-section> | <control-line> | <text-line> | # <non-directive>

<if-section> ::= <if-group> <elif-groups>? <else-group>? <endif-line>

<if-group> ::= # if <constant-expression> <new-line> <group>? | # ifdef <identifier> <new-line> <group>? | # ifndef <identifier> <new-line> <group>?

<elif-groups> ::= <elif-group>+

<elif-group> ::= # elif <constant-expression> <new-line> <group>?

<else-group> ::= # else <new-line> <group>?

<endif-line> ::= # endif <new-line>

<control-line> ::= # include <pp-tokens> <new-line> | # define <identifier> <replacement-list> <new-line> | # define <identifier> <lparen> <identifier-list>? <rparen> <replacement-list> <new-line> | # undef <identifier> <new-line> | # line <pp-tokens> <new-line> | # error <pp-tokens>? <new-line> | # pragma <pp-tokens>? <new-line> | # <new-line>

<text-line> ::= <pp-tokens>? <new-line>

<non-directive> ::= <pp-tokens> <new-line>

<lparen> ::= a ( character not immediately preceded by white-space

<replacement-list> ::= <pp-tokens>?

<pp-tokens> ::= <preprocessing-token>+

<new-line> ::= the new-line character


