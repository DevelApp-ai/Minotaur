# JSON Grammar Definition
# Based on RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format
# https://tools.ietf.org/html/rfc7159

grammar JSON;

// Entry point
json
    : element
    ;

// Core elements
element
    : value
    ;

value
    : object
    | array
    | string
    | number
    | boolean
    | null
    ;

// Object structure
object
    : '{' ws '}'
    | '{' members '}'
    ;

members
    : member
    | member ',' members
    ;

member
    : ws string ws ':' element
    ;

// Array structure
array
    : '[' ws ']'
    | '[' elements ']'
    ;

elements
    : element
    | element ',' elements
    ;

// String literals
string
    : '"' characters '"'
    ;

characters
    : /* empty */
    | character characters
    ;

character
    : ~["\\\u0000-\u001F]
    | escape
    ;

escape
    : '\\"'
    | '\\\\'
    | '\\/'
    | '\\b'
    | '\\f'
    | '\\n'
    | '\\r'
    | '\\t'
    | '\\u' hex hex hex hex
    ;

hex
    : [0-9a-fA-F]
    ;

// Number literals
number
    : integer
    | integer fraction
    | integer exponent
    | integer fraction exponent
    ;

integer
    : digit
    | onenine digits
    | '-' digit
    | '-' onenine digits
    ;

digits
    : digit
    | digit digits
    ;

digit
    : [0-9]
    ;

onenine
    : [1-9]
    ;

fraction
    : '.' digits
    ;

exponent
    : 'E' sign digits
    | 'e' sign digits
    ;

sign
    : /* empty */
    | '+'
    | '-'
    ;

// Boolean literals
boolean
    : 'true'
    | 'false'
    ;

// Null literal
null
    : 'null'
    ;

// Whitespace
ws
    : /* empty */
    | ws_char ws
    ;

ws_char
    : ' '
    | '\t'
    | '\n'
    | '\r'
    ;

// Lexer rules for tokens
STRING
    : '"' (ESC | SAFECODEPOINT)* '"'
    ;

fragment ESC
    : '\\' (["\\/bfnrt] | UNICODE)
    ;

fragment UNICODE
    : 'u' HEX HEX HEX HEX
    ;

fragment HEX
    : [0-9a-fA-F]
    ;

fragment SAFECODEPOINT
    : ~["\\\u0000-\u001F]
    ;

NUMBER
    : '-'? INT ('.' [0-9]+)? EXP?
    ;

fragment INT
    : '0'
    | [1-9] [0-9]*
    ;

fragment EXP
    : [Ee] [+\-]? INT
    ;

TRUE
    : 'true'
    ;

FALSE
    : 'false'
    ;

NULL
    : 'null'
    ;

WS
    : [ \t\n\r]+ -> skip
    ;

// Error handling
INVALID_STRING
    : '"' (~["\\\r\n] | ESC)* ([\r\n] | EOF)
    ;

INVALID_NUMBER
    : '-'? [0-9]+ '.' [0-9]* [eE] [+\-]?
    | '-'? [0-9]+ [eE] [+\-]?
    | '-'? '.' [0-9]+
    ;

// Comments (non-standard but commonly supported)
LINE_COMMENT
    : '//' ~[\r\n]* -> skip
    ;

BLOCK_COMMENT
    : '/*' .*? '*/' -> skip
    ;

// Semantic actions and attributes
@header {
    // JSON Grammar Semantic Actions
    // This section defines semantic actions for AST construction
}

@members {
    // Helper methods for JSON parsing and validation
    
    public boolean isValidUnicodeEscape(String unicode) {
        try {
            int codePoint = Integer.parseInt(unicode, 16);
            return Character.isValidCodePoint(codePoint);
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    public boolean isValidNumber(String number) {
        try {
            if (number.contains(".") || number.toLowerCase().contains("e")) {
                Double.parseDouble(number);
            } else {
                Long.parseLong(number);
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    public Object parseJsonValue(String text) {
        // Parse JSON value and return appropriate Java object
        if (text.equals("null")) return null;
        if (text.equals("true")) return Boolean.TRUE;
        if (text.equals("false")) return Boolean.FALSE;
        if (text.startsWith("\"")) return parseString(text);
        if (Character.isDigit(text.charAt(0)) || text.charAt(0) == '-') {
            return parseNumber(text);
        }
        return text; // fallback
    }
    
    private String parseString(String text) {
        // Remove quotes and process escape sequences
        String content = text.substring(1, text.length() - 1);
        return processEscapes(content);
    }
    
    private String processEscapes(String content) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < content.length(); i++) {
            char c = content.charAt(i);
            if (c == '\\' && i + 1 < content.length()) {
                char next = content.charAt(i + 1);
                switch (next) {
                    case '"': result.append('"'); i++; break;
                    case '\\': result.append('\\'); i++; break;
                    case '/': result.append('/'); i++; break;
                    case 'b': result.append('\b'); i++; break;
                    case 'f': result.append('\f'); i++; break;
                    case 'n': result.append('\n'); i++; break;
                    case 'r': result.append('\r'); i++; break;
                    case 't': result.append('\t'); i++; break;
                    case 'u':
                        if (i + 5 < content.length()) {
                            String unicode = content.substring(i + 2, i + 6);
                            int codePoint = Integer.parseInt(unicode, 16);
                            result.append((char) codePoint);
                            i += 5;
                        } else {
                            result.append(c);
                        }
                        break;
                    default:
                        result.append(c);
                        break;
                }
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }
    
    private Number parseNumber(String text) {
        if (text.contains(".") || text.toLowerCase().contains("e")) {
            return Double.parseDouble(text);
        } else {
            long value = Long.parseLong(text);
            if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
                return (int) value;
            }
            return value;
        }
    }
}

// AST node definitions for semantic analysis
@parser::header {
    import java.util.*;
    import java.math.*;
}

// Production rules with semantic actions
json returns [Object value]
    : element { $value = $element.value; }
    ;

element returns [Object value]
    : value { $value = $value.value; }
    ;

value returns [Object value]
    : object { $value = $object.value; }
    | array { $value = $array.value; }
    | string { $value = $string.value; }
    | number { $value = $number.value; }
    | boolean { $value = $boolean.value; }
    | null { $value = null; }
    ;

object returns [Map<String, Object> value]
@init { $value = new LinkedHashMap<>(); }
    : '{' ws '}'
    | '{' members { $value = $members.value; } '}'
    ;

members returns [Map<String, Object> value]
@init { $value = new LinkedHashMap<>(); }
    : member { $value.put($member.key, $member.value); }
    | member ',' members { 
        $value = $members.value;
        $value.put($member.key, $member.value);
      }
    ;

member returns [String key, Object value]
    : ws string ws ':' element {
        $key = $string.value;
        $value = $element.value;
      }
    ;

array returns [List<Object> value]
@init { $value = new ArrayList<>(); }
    : '[' ws ']'
    | '[' elements { $value = $elements.value; } ']'
    ;

elements returns [List<Object> value]
@init { $value = new ArrayList<>(); }
    : element { $value.add($element.value); }
    | element ',' elements {
        $value = $elements.value;
        $value.add(0, $element.value);
      }
    ;

string returns [String value]
    : STRING { $value = parseString($STRING.text); }
    ;

number returns [Number value]
    : NUMBER { $value = parseNumber($NUMBER.text); }
    ;

boolean returns [Boolean value]
    : TRUE { $value = Boolean.TRUE; }
    | FALSE { $value = Boolean.FALSE; }
    ;

null returns [Object value]
    : NULL { $value = null; }
    ;

// Error recovery rules
@rulecatch {
    catch (RecognitionException re) {
        reportError(re);
        recover(input, re);
    }
}

// Grammar metadata
@grammar::header {
    /**
     * JSON Grammar for Minotaur Parser
     * 
     * This grammar provides comprehensive support for JSON parsing including:
     * - RFC 7159 compliant JSON syntax
     * - Semantic actions for AST construction
     * - Error handling and recovery
     * - Support for comments (non-standard extension)
     * - Unicode escape sequence processing
     * - Number validation and parsing
     * 
     * Features:
     * - Complete JSON syntax support
     * - Semantic value extraction
     * - Error recovery mechanisms
     * - AST node construction
     * - Type-safe value parsing
     * 
     * Usage:
     * - Parse JSON documents into AST
     * - Extract semantic values
     * - Validate JSON syntax
     * - Support for interactive translation
     * 
     * @version 1.0
     * @author Minotaur Team
     * @since 2024
     */
}

