# JSON Schema Grammar Definition
# Based on JSON Schema Draft 2020-12 (Draft 8)
# https://json-schema.org/draft/2020-12/schema

grammar JSONSchema;

import JSON;

// Entry point for JSON Schema
schema
    : schemaDocument
    ;

schemaDocument
    : object
    | boolean
    ;

// Core schema keywords
schemaKeywords
    : typeKeyword
    | formatKeyword
    | validationKeywords
    | applicatorKeywords
    | annotationKeywords
    | metaSchemaKeywords
    | conditionalKeywords
    | logicalKeywords
    ;

// Type specification
typeKeyword
    : '"type"' ':' typeValue
    ;

typeValue
    : simpleType
    | typeArray
    ;

simpleType
    : '"null"'
    | '"boolean"'
    | '"object"'
    | '"array"'
    | '"number"'
    | '"integer"'
    | '"string"'
    ;

typeArray
    : '[' typeList ']'
    ;

typeList
    : simpleType
    | simpleType ',' typeList
    ;

// Format specification
formatKeyword
    : '"format"' ':' formatValue
    ;

formatValue
    : stringFormat
    | dateTimeFormat
    | emailFormat
    | uriFormat
    | regexFormat
    | customFormat
    ;

stringFormat
    : '"date-time"'
    | '"time"'
    | '"date"'
    | '"duration"'
    | '"email"'
    | '"idn-email"'
    | '"hostname"'
    | '"idn-hostname"'
    | '"ipv4"'
    | '"ipv6"'
    | '"uri"'
    | '"uri-reference"'
    | '"iri"'
    | '"iri-reference"'
    | '"uri-template"'
    | '"json-pointer"'
    | '"relative-json-pointer"'
    | '"regex"'
    | '"uuid"'
    ;

dateTimeFormat
    : '"date-time"'
    | '"date"'
    | '"time"'
    ;

emailFormat
    : '"email"'
    | '"idn-email"'
    ;

uriFormat
    : '"uri"'
    | '"uri-reference"'
    | '"iri"'
    | '"iri-reference"'
    | '"uri-template"'
    ;

regexFormat
    : '"regex"'
    ;

customFormat
    : string
    ;

// Validation keywords
validationKeywords
    : numericValidation
    | stringValidation
    | arrayValidation
    | objectValidation
    | genericValidation
    ;

// Numeric validation
numericValidation
    : multipleOfKeyword
    | maximumKeyword
    | exclusiveMaximumKeyword
    | minimumKeyword
    | exclusiveMinimumKeyword
    ;

multipleOfKeyword
    : '"multipleOf"' ':' positiveNumber
    ;

maximumKeyword
    : '"maximum"' ':' number
    ;

exclusiveMaximumKeyword
    : '"exclusiveMaximum"' ':' number
    ;

minimumKeyword
    : '"minimum"' ':' number
    ;

exclusiveMinimumKeyword
    : '"exclusiveMinimum"' ':' number
    ;

// String validation
stringValidation
    : maxLengthKeyword
    | minLengthKeyword
    | patternKeyword
    ;

maxLengthKeyword
    : '"maxLength"' ':' nonNegativeInteger
    ;

minLengthKeyword
    : '"minLength"' ':' nonNegativeInteger
    ;

patternKeyword
    : '"pattern"' ':' string
    ;

// Array validation
arrayValidation
    : maxItemsKeyword
    | minItemsKeyword
    | uniqueItemsKeyword
    | maxContainsKeyword
    | minContainsKeyword
    ;

maxItemsKeyword
    : '"maxItems"' ':' nonNegativeInteger
    ;

minItemsKeyword
    : '"minItems"' ':' nonNegativeInteger
    ;

uniqueItemsKeyword
    : '"uniqueItems"' ':' boolean
    ;

maxContainsKeyword
    : '"maxContains"' ':' nonNegativeInteger
    ;

minContainsKeyword
    : '"minContains"' ':' nonNegativeInteger
    ;

// Object validation
objectValidation
    : maxPropertiesKeyword
    | minPropertiesKeyword
    | requiredKeyword
    | dependentRequiredKeyword
    ;

maxPropertiesKeyword
    : '"maxProperties"' ':' nonNegativeInteger
    ;

minPropertiesKeyword
    : '"minProperties"' ':' nonNegativeInteger
    ;

requiredKeyword
    : '"required"' ':' stringArray
    ;

dependentRequiredKeyword
    : '"dependentRequired"' ':' dependentRequiredObject
    ;

dependentRequiredObject
    : '{' dependentRequiredMembers '}'
    ;

dependentRequiredMembers
    : dependentRequiredMember
    | dependentRequiredMember ',' dependentRequiredMembers
    ;

dependentRequiredMember
    : string ':' stringArray
    ;

// Generic validation
genericValidation
    : enumKeyword
    | constKeyword
    ;

enumKeyword
    : '"enum"' ':' array
    ;

constKeyword
    : '"const"' ':' value
    ;

// Applicator keywords
applicatorKeywords
    : itemsKeyword
    | additionalItemsKeyword
    | unevaluatedItemsKeyword
    | containsKeyword
    | propertiesKeyword
    | patternPropertiesKeyword
    | additionalPropertiesKeyword
    | unevaluatedPropertiesKeyword
    | propertyNamesKeyword
    ;

itemsKeyword
    : '"items"' ':' schemaOrSchemaArray
    ;

additionalItemsKeyword
    : '"additionalItems"' ':' schema
    ;

unevaluatedItemsKeyword
    : '"unevaluatedItems"' ':' schema
    ;

containsKeyword
    : '"contains"' ':' schema
    ;

propertiesKeyword
    : '"properties"' ':' propertiesObject
    ;

propertiesObject
    : '{' propertiesMembers '}'
    ;

propertiesMembers
    : propertiesMember
    | propertiesMember ',' propertiesMembers
    ;

propertiesMember
    : string ':' schema
    ;

patternPropertiesKeyword
    : '"patternProperties"' ':' patternPropertiesObject
    ;

patternPropertiesObject
    : '{' patternPropertiesMembers '}'
    ;

patternPropertiesMembers
    : patternPropertiesMember
    | patternPropertiesMember ',' patternPropertiesMembers
    ;

patternPropertiesMember
    : string ':' schema
    ;

additionalPropertiesKeyword
    : '"additionalProperties"' ':' schema
    ;

unevaluatedPropertiesKeyword
    : '"unevaluatedProperties"' ':' schema
    ;

propertyNamesKeyword
    : '"propertyNames"' ':' schema
    ;

// Annotation keywords
annotationKeywords
    : titleKeyword
    | descriptionKeyword
    | defaultKeyword
    | deprecatedKeyword
    | readOnlyKeyword
    | writeOnlyKeyword
    | examplesKeyword
    ;

titleKeyword
    : '"title"' ':' string
    ;

descriptionKeyword
    : '"description"' ':' string
    ;

defaultKeyword
    : '"default"' ':' value
    ;

deprecatedKeyword
    : '"deprecated"' ':' boolean
    ;

readOnlyKeyword
    : '"readOnly"' ':' boolean
    ;

writeOnlyKeyword
    : '"writeOnly"' ':' boolean
    ;

examplesKeyword
    : '"examples"' ':' array
    ;

// Meta-schema keywords
metaSchemaKeywords
    : schemaKeyword
    | vocabularyKeyword
    | idKeyword
    | anchorKeyword
    | dynamicAnchorKeyword
    | refKeyword
    | dynamicRefKeyword
    | defsKeyword
    | commentKeyword
    ;

schemaKeyword
    : '"$schema"' ':' string
    ;

vocabularyKeyword
    : '"$vocabulary"' ':' vocabularyObject
    ;

vocabularyObject
    : '{' vocabularyMembers '}'
    ;

vocabularyMembers
    : vocabularyMember
    | vocabularyMember ',' vocabularyMembers
    ;

vocabularyMember
    : string ':' boolean
    ;

idKeyword
    : '"$id"' ':' string
    ;

anchorKeyword
    : '"$anchor"' ':' string
    ;

dynamicAnchorKeyword
    : '"$dynamicAnchor"' ':' string
    ;

refKeyword
    : '"$ref"' ':' string
    ;

dynamicRefKeyword
    : '"$dynamicRef"' ':' string
    ;

defsKeyword
    : '"$defs"' ':' defsObject
    ;

defsObject
    : '{' defsMembers '}'
    ;

defsMembers
    : defsMember
    | defsMember ',' defsMembers
    ;

defsMember
    : string ':' schema
    ;

commentKeyword
    : '"$comment"' ':' string
    ;

// Conditional keywords
conditionalKeywords
    : ifKeyword
    | thenKeyword
    | elseKeyword
    | dependentSchemasKeyword
    ;

ifKeyword
    : '"if"' ':' schema
    ;

thenKeyword
    : '"then"' ':' schema
    ;

elseKeyword
    : '"else"' ':' schema
    ;

dependentSchemasKeyword
    : '"dependentSchemas"' ':' dependentSchemasObject
    ;

dependentSchemasObject
    : '{' dependentSchemasMembers '}'
    ;

dependentSchemasMembers
    : dependentSchemasMember
    | dependentSchemasMember ',' dependentSchemasMembers
    ;

dependentSchemasMember
    : string ':' schema
    ;

// Logical keywords
logicalKeywords
    : allOfKeyword
    | anyOfKeyword
    | oneOfKeyword
    | notKeyword
    ;

allOfKeyword
    : '"allOf"' ':' schemaArray
    ;

anyOfKeyword
    : '"anyOf"' ':' schemaArray
    ;

oneOfKeyword
    : '"oneOf"' ':' schemaArray
    ;

notKeyword
    : '"not"' ':' schema
    ;

// Helper rules
schemaOrSchemaArray
    : schema
    | schemaArray
    ;

schemaArray
    : '[' schemaList ']'
    ;

schemaList
    : schema
    | schema ',' schemaList
    ;

stringArray
    : '[' stringList ']'
    ;

stringList
    : string
    | string ',' stringList
    ;

positiveNumber
    : number { $number.value > 0 }?
    ;

nonNegativeInteger
    : number { $number.value >= 0 && $number.value == Math.floor($number.value) }?
    ;

// Semantic actions for JSON Schema validation
@members {
    // JSON Schema validation helpers
    
    public boolean isValidSchemaType(String type) {
        return Arrays.asList("null", "boolean", "object", "array", "number", "integer", "string")
                     .contains(type);
    }
    
    public boolean isValidFormat(String format) {
        Set<String> validFormats = new HashSet<>(Arrays.asList(
            "date-time", "time", "date", "duration", "email", "idn-email",
            "hostname", "idn-hostname", "ipv4", "ipv6", "uri", "uri-reference",
            "iri", "iri-reference", "uri-template", "json-pointer",
            "relative-json-pointer", "regex", "uuid"
        ));
        return validFormats.contains(format);
    }
    
    public boolean isValidRegex(String pattern) {
        try {
            java.util.regex.Pattern.compile(pattern);
            return true;
        } catch (java.util.regex.PatternSyntaxException e) {
            return false;
        }
    }
    
    public boolean isValidUri(String uri) {
        try {
            new java.net.URI(uri);
            return true;
        } catch (java.net.URISyntaxException e) {
            return false;
        }
    }
    
    public boolean isValidJsonPointer(String pointer) {
        return pointer.startsWith("/") || pointer.equals("");
    }
    
    public Map<String, Object> createSchemaNode(String keyword, Object value) {
        Map<String, Object> node = new HashMap<>();
        node.put("keyword", keyword);
        node.put("value", value);
        node.put("location", getCurrentLocation());
        return node;
    }
    
    private String getCurrentLocation() {
        // Return current parsing location for error reporting
        return "line " + getCurrentToken().getLine() + 
               ", column " + getCurrentToken().getCharPositionInLine();
    }
    
    public void validateSchemaConstraints(Map<String, Object> schema) {
        // Validate schema-level constraints
        if (schema.containsKey("minimum") && schema.containsKey("maximum")) {
            Number min = (Number) schema.get("minimum");
            Number max = (Number) schema.get("maximum");
            if (min.doubleValue() > max.doubleValue()) {
                throw new RuntimeException("minimum cannot be greater than maximum");
            }
        }
        
        if (schema.containsKey("minLength") && schema.containsKey("maxLength")) {
            Number minLen = (Number) schema.get("minLength");
            Number maxLen = (Number) schema.get("maxLength");
            if (minLen.intValue() > maxLen.intValue()) {
                throw new RuntimeException("minLength cannot be greater than maxLength");
            }
        }
        
        if (schema.containsKey("minItems") && schema.containsKey("maxItems")) {
            Number minItems = (Number) schema.get("minItems");
            Number maxItems = (Number) schema.get("maxItems");
            if (minItems.intValue() > maxItems.intValue()) {
                throw new RuntimeException("minItems cannot be greater than maxItems");
            }
        }
        
        if (schema.containsKey("minProperties") && schema.containsKey("maxProperties")) {
            Number minProps = (Number) schema.get("minProperties");
            Number maxProps = (Number) schema.get("maxProperties");
            if (minProps.intValue() > maxProps.intValue()) {
                throw new RuntimeException("minProperties cannot be greater than maxProperties");
            }
        }
    }
}

// Production rules with semantic actions for schema construction
schema returns [Map<String, Object> value]
@init { $value = new HashMap<>(); }
    : schemaDocument { $value = $schemaDocument.value; }
    ;

schemaDocument returns [Map<String, Object> value]
    : object { 
        $value = (Map<String, Object>) $object.value;
        validateSchemaConstraints($value);
      }
    | boolean { 
        $value = new HashMap<>();
        $value.put("type", "boolean");
        $value.put("const", $boolean.value);
      }
    ;

// Enhanced error handling for JSON Schema
@rulecatch {
    catch (RecognitionException re) {
        String msg = "JSON Schema syntax error at " + getCurrentLocation() + ": " + re.getMessage();
        reportError(re);
        recover(input, re);
    }
}

// Grammar metadata for JSON Schema
@grammar::header {
    /**
     * JSON Schema Grammar for Minotaur Parser
     * 
     * This grammar provides comprehensive support for JSON Schema parsing including:
     * - JSON Schema Draft 2020-12 compliance
     * - All core vocabulary keywords
     * - Semantic validation and constraint checking
     * - AST construction with schema metadata
     * - Error handling and recovery
     * 
     * Supported vocabularies:
     * - Core vocabulary (meta-schema keywords)
     * - Applicator vocabulary (schema application)
     * - Validation vocabulary (instance validation)
     * - Format-Annotation vocabulary (semantic validation)
     * - Content vocabulary (content encoding/media type)
     * 
     * Features:
     * - Complete JSON Schema syntax support
     * - Schema validation and constraint checking
     * - Reference resolution support
     * - Conditional schema application
     * - Logical schema composition
     * - Format validation
     * - Custom vocabulary support
     * 
     * Usage:
     * - Parse JSON Schema documents
     * - Validate schema syntax and semantics
     * - Generate schema AST for processing
     * - Support for interactive schema translation
     * 
     * @version 1.0
     * @author Minotaur Team
     * @since 2024
     */
}

// Additional lexer rules for JSON Schema specific tokens
SCHEMA_KEYWORD
    : '$schema'
    | '$id'
    | '$ref'
    | '$anchor'
    | '$dynamicAnchor'
    | '$dynamicRef'
    | '$vocabulary'
    | '$comment'
    | '$defs'
    ;

TYPE_KEYWORD
    : 'type'
    | 'format'
    | 'enum'
    | 'const'
    ;

VALIDATION_KEYWORD
    : 'multipleOf'
    | 'maximum'
    | 'exclusiveMaximum'
    | 'minimum'
    | 'exclusiveMinimum'
    | 'maxLength'
    | 'minLength'
    | 'pattern'
    | 'maxItems'
    | 'minItems'
    | 'uniqueItems'
    | 'maxContains'
    | 'minContains'
    | 'maxProperties'
    | 'minProperties'
    | 'required'
    | 'dependentRequired'
    ;

APPLICATOR_KEYWORD
    : 'items'
    | 'additionalItems'
    | 'unevaluatedItems'
    | 'contains'
    | 'properties'
    | 'patternProperties'
    | 'additionalProperties'
    | 'unevaluatedProperties'
    | 'propertyNames'
    ;

ANNOTATION_KEYWORD
    : 'title'
    | 'description'
    | 'default'
    | 'deprecated'
    | 'readOnly'
    | 'writeOnly'
    | 'examples'
    ;

CONDITIONAL_KEYWORD
    : 'if'
    | 'then'
    | 'else'
    | 'dependentSchemas'
    ;

LOGICAL_KEYWORD
    : 'allOf'
    | 'anyOf'
    | 'oneOf'
    | 'not'
    ;

// Format validation patterns
DATE_TIME_FORMAT
    : 'date-time'
    | 'time'
    | 'date'
    | 'duration'
    ;

STRING_FORMAT
    : 'email'
    | 'idn-email'
    | 'hostname'
    | 'idn-hostname'
    | 'ipv4'
    | 'ipv6'
    | 'uri'
    | 'uri-reference'
    | 'iri'
    | 'iri-reference'
    | 'uri-template'
    | 'json-pointer'
    | 'relative-json-pointer'
    | 'regex'
    | 'uuid'
    ;

