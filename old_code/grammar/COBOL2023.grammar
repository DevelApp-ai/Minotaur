/*
 * COBOL 2023 Grammar Specification
 * 
 * This grammar supports the latest COBOL 2023 standard (ISO/IEC 1989:2023)
 * including modern features like JSON support, object-oriented programming,
 * XML processing, web services, and enhanced data types.
 * 
 * Features covered:
 * - COBOL 2023 standard compliance
 * - Object-oriented programming (OOP)
 * - JSON and XML processing
 * - Web services and REST API support
 * - Enhanced data types and structures
 * - Modern file handling
 * - Exception handling
 * - Unicode and internationalization
 * - Database connectivity (SQL)
 * - Legacy compatibility
 */

grammar COBOL2023;

// ============================================================================
// LEXER RULES
// ============================================================================

// Keywords
ACCEPT          : 'ACCEPT' ;
ACCESS          : 'ACCESS' ;
ADD             : 'ADD' ;
ADVANCING       : 'ADVANCING' ;
AFTER           : 'AFTER' ;
ALL             : 'ALL' ;
ALPHABETIC      : 'ALPHABETIC' ;
ALPHABETIC_LOWER: 'ALPHABETIC-LOWER' ;
ALPHABETIC_UPPER: 'ALPHABETIC-UPPER' ;
ALPHANUMERIC    : 'ALPHANUMERIC' ;
ALPHANUMERIC_EDITED: 'ALPHANUMERIC-EDITED' ;
ALSO            : 'ALSO' ;
ALTER           : 'ALTER' ;
ALTERNATE       : 'ALTERNATE' ;
AND             : 'AND' ;
ANY             : 'ANY' ;
AREA            : 'AREA' ;
AREAS           : 'AREAS' ;
ASCENDING       : 'ASCENDING' ;
ASSIGN          : 'ASSIGN' ;
AT              : 'AT' ;
AUTHOR          : 'AUTHOR' ;
BEFORE          : 'BEFORE' ;
BINARY          : 'BINARY' ;
BLANK           : 'BLANK' ;
BLOCK           : 'BLOCK' ;
BOTTOM          : 'BOTTOM' ;
BY              : 'BY' ;
CALL            : 'CALL' ;
CANCEL          : 'CANCEL' ;
CD              : 'CD' ;
CF              : 'CF' ;
CH              : 'CH' ;
CHARACTER       : 'CHARACTER' ;
CHARACTERS      : 'CHARACTERS' ;
CLASS           : 'CLASS' ;
CLASS_ID        : 'CLASS-ID' ;
CLOCK_UNITS     : 'CLOCK-UNITS' ;
CLOSE           : 'CLOSE' ;
COBOL           : 'COBOL' ;
CODE            : 'CODE' ;
CODE_SET        : 'CODE-SET' ;
COLLATING       : 'COLLATING' ;
COLUMN          : 'COLUMN' ;
COMMA           : 'COMMA' ;
COMMON          : 'COMMON' ;
COMMUNICATION   : 'COMMUNICATION' ;
COMP            : 'COMP' ;
COMP_1          : 'COMP-1' ;
COMP_2          : 'COMP-2' ;
COMP_3          : 'COMP-3' ;
COMP_4          : 'COMP-4' ;
COMP_5          : 'COMP-5' ;
COMPUTATIONAL   : 'COMPUTATIONAL' ;
COMPUTATIONAL_1 : 'COMPUTATIONAL-1' ;
COMPUTATIONAL_2 : 'COMPUTATIONAL-2' ;
COMPUTATIONAL_3 : 'COMPUTATIONAL-3' ;
COMPUTATIONAL_4 : 'COMPUTATIONAL-4' ;
COMPUTATIONAL_5 : 'COMPUTATIONAL-5' ;
COMPUTE         : 'COMPUTE' ;
CONFIGURATION   : 'CONFIGURATION' ;
CONTAINS        : 'CONTAINS' ;
CONTENT         : 'CONTENT' ;
CONTINUE        : 'CONTINUE' ;
CONTROL         : 'CONTROL' ;
CONTROLS        : 'CONTROLS' ;
CONVERTING      : 'CONVERTING' ;
COPY            : 'COPY' ;
CORR            : 'CORR' ;
CORRESPONDING   : 'CORRESPONDING' ;
COUNT           : 'COUNT' ;
CURRENCY        : 'CURRENCY' ;
DATA            : 'DATA' ;
DATE            : 'DATE' ;
DATE_COMPILED   : 'DATE-COMPILED' ;
DATE_WRITTEN    : 'DATE-WRITTEN' ;
DAY             : 'DAY' ;
DAY_OF_WEEK     : 'DAY-OF-WEEK' ;
DE              : 'DE' ;
DEBUG_CONTENTS  : 'DEBUG-CONTENTS' ;
DEBUG_ITEM      : 'DEBUG-ITEM' ;
DEBUG_LINE      : 'DEBUG-LINE' ;
DEBUG_NAME      : 'DEBUG-NAME' ;
DEBUG_SUB_1     : 'DEBUG-SUB-1' ;
DEBUG_SUB_2     : 'DEBUG-SUB-2' ;
DEBUG_SUB_3     : 'DEBUG-SUB-3' ;
DEBUGGING       : 'DEBUGGING' ;
DECIMAL_POINT   : 'DECIMAL-POINT' ;
DECLARATIVES    : 'DECLARATIVES' ;
DELETE          : 'DELETE' ;
DELIMITED       : 'DELIMITED' ;
DELIMITER       : 'DELIMITER' ;
DEPENDING       : 'DEPENDING' ;
DESCENDING      : 'DESCENDING' ;
DESTINATION     : 'DESTINATION' ;
DETAIL          : 'DETAIL' ;
DISABLE         : 'DISABLE' ;
DISPLAY         : 'DISPLAY' ;
DIVIDE          : 'DIVIDE' ;
DIVISION        : 'DIVISION' ;
DOWN            : 'DOWN' ;
DUPLICATES      : 'DUPLICATES' ;
DYNAMIC         : 'DYNAMIC' ;
EGI             : 'EGI' ;
ELSE            : 'ELSE' ;
EMI             : 'EMI' ;
ENABLE          : 'ENABLE' ;
END             : 'END' ;
END_ADD         : 'END-ADD' ;
END_CALL        : 'END-CALL' ;
END_COMPUTE     : 'END-COMPUTE' ;
END_DELETE      : 'END-DELETE' ;
END_DIVIDE      : 'END-DIVIDE' ;
END_EVALUATE    : 'END-EVALUATE' ;
END_IF          : 'END-IF' ;
END_MULTIPLY    : 'END-MULTIPLY' ;
END_OF_PAGE     : 'END-OF-PAGE' ;
END_PERFORM     : 'END-PERFORM' ;
END_READ        : 'END-READ' ;
END_RECEIVE     : 'END-RECEIVE' ;
END_RETURN      : 'END-RETURN' ;
END_REWRITE     : 'END-REWRITE' ;
END_SEARCH      : 'END-SEARCH' ;
END_START       : 'END-START' ;
END_STRING      : 'END-STRING' ;
END_SUBTRACT    : 'END-SUBTRACT' ;
END_UNSTRING    : 'END-UNSTRING' ;
END_WRITE       : 'END-WRITE' ;
ENTER           : 'ENTER' ;
ENVIRONMENT     : 'ENVIRONMENT' ;
EOP             : 'EOP' ;
EQUAL           : 'EQUAL' ;
ERROR           : 'ERROR' ;
ESI             : 'ESI' ;
EVALUATE        : 'EVALUATE' ;
EVERY           : 'EVERY' ;
EXCEPTION       : 'EXCEPTION' ;
EXIT            : 'EXIT' ;
EXTEND          : 'EXTEND' ;
EXTERNAL        : 'EXTERNAL' ;
FD              : 'FD' ;
FILE            : 'FILE' ;
FILE_CONTROL    : 'FILE-CONTROL' ;
FILLER          : 'FILLER' ;
FINAL           : 'FINAL' ;
FIRST           : 'FIRST' ;
FOOTING         : 'FOOTING' ;
FOR             : 'FOR' ;
FROM            : 'FROM' ;
FUNCTION        : 'FUNCTION' ;
GENERATE        : 'GENERATE' ;
GIVING          : 'GIVING' ;
GLOBAL          : 'GLOBAL' ;
GO              : 'GO' ;
GREATER         : 'GREATER' ;
GROUP           : 'GROUP' ;
HEADING         : 'HEADING' ;
HIGH_VALUE      : 'HIGH-VALUE' ;
HIGH_VALUES     : 'HIGH-VALUES' ;
I_O             : 'I-O' ;
I_O_CONTROL     : 'I-O-CONTROL' ;
IDENTIFICATION  : 'IDENTIFICATION' ;
IF              : 'IF' ;
IN              : 'IN' ;
INDEX           : 'INDEX' ;
INDEXED         : 'INDEXED' ;
INDICATE        : 'INDICATE' ;
INITIAL         : 'INITIAL' ;
INITIALIZE      : 'INITIALIZE' ;
INITIATE        : 'INITIATE' ;
INPUT           : 'INPUT' ;
INPUT_OUTPUT    : 'INPUT-OUTPUT' ;
INSPECT         : 'INSPECT' ;
INSTALLATION    : 'INSTALLATION' ;
INTO            : 'INTO' ;
INVALID         : 'INVALID' ;
IS              : 'IS' ;
JUST            : 'JUST' ;
JUSTIFIED       : 'JUSTIFIED' ;
KEY             : 'KEY' ;
LABEL           : 'LABEL' ;
LAST            : 'LAST' ;
LEADING         : 'LEADING' ;
LEFT            : 'LEFT' ;
LENGTH          : 'LENGTH' ;
LESS            : 'LESS' ;
LIMIT           : 'LIMIT' ;
LIMITS          : 'LIMITS' ;
LINAGE          : 'LINAGE' ;
LINAGE_COUNTER  : 'LINAGE-COUNTER' ;
LINE            : 'LINE' ;
LINES           : 'LINES' ;
LINKAGE         : 'LINKAGE' ;
LOCK            : 'LOCK' ;
LOW_VALUE       : 'LOW-VALUE' ;
LOW_VALUES      : 'LOW-VALUES' ;
MEMORY          : 'MEMORY' ;
MERGE           : 'MERGE' ;
MESSAGE         : 'MESSAGE' ;
MODE            : 'MODE' ;
MODULES         : 'MODULES' ;
MOVE            : 'MOVE' ;
MULTIPLE        : 'MULTIPLE' ;
MULTIPLY        : 'MULTIPLY' ;
NATIVE          : 'NATIVE' ;
NEGATIVE        : 'NEGATIVE' ;
NEXT            : 'NEXT' ;
NO              : 'NO' ;
NOT             : 'NOT' ;
NULL            : 'NULL' ;
NULLS           : 'NULLS' ;
NUMBER          : 'NUMBER' ;
NUMERIC         : 'NUMERIC' ;
NUMERIC_EDITED  : 'NUMERIC-EDITED' ;
OBJECT_COMPUTER : 'OBJECT-COMPUTER' ;
OCCURS          : 'OCCURS' ;
OF              : 'OF' ;
OFF             : 'OFF' ;
OMITTED         : 'OMITTED' ;
ON              : 'ON' ;
OPEN            : 'OPEN' ;
OPTIONAL        : 'OPTIONAL' ;
OR              : 'OR' ;
ORDER           : 'ORDER' ;
ORGANIZATION    : 'ORGANIZATION' ;
OTHER           : 'OTHER' ;
OUTPUT          : 'OUTPUT' ;
OVERFLOW        : 'OVERFLOW' ;
PACKED_DECIMAL  : 'PACKED-DECIMAL' ;
PADDING         : 'PADDING' ;
PAGE            : 'PAGE' ;
PAGE_COUNTER    : 'PAGE-COUNTER' ;
PERFORM         : 'PERFORM' ;
PF              : 'PF' ;
PH              : 'PH' ;
PIC             : 'PIC' ;
PICTURE         : 'PICTURE' ;
PLUS            : 'PLUS' ;
POINTER         : 'POINTER' ;
POSITION        : 'POSITION' ;
POSITIVE        : 'POSITIVE' ;
PROCEDURE       : 'PROCEDURE' ;
PROCEDURES      : 'PROCEDURES' ;
PROCEED         : 'PROCEED' ;
PROGRAM         : 'PROGRAM' ;
PROGRAM_ID      : 'PROGRAM-ID' ;
PURGE           : 'PURGE' ;
QUEUE           : 'QUEUE' ;
QUOTE           : 'QUOTE' ;
QUOTES          : 'QUOTES' ;
RANDOM          : 'RANDOM' ;
RD              : 'RD' ;
READ            : 'READ' ;
RECEIVE         : 'RECEIVE' ;
RECORD          : 'RECORD' ;
RECORDS         : 'RECORDS' ;
REDEFINES       : 'REDEFINES' ;
REEL            : 'REEL' ;
REFERENCE       : 'REFERENCE' ;
REFERENCES      : 'REFERENCES' ;
RELATIVE        : 'RELATIVE' ;
RELEASE         : 'RELEASE' ;
REMAINDER       : 'REMAINDER' ;
REMOVAL         : 'REMOVAL' ;
RENAMES         : 'RENAMES' ;
REPLACE         : 'REPLACE' ;
REPLACING       : 'REPLACING' ;
REPORT          : 'REPORT' ;
REPORTS         : 'REPORTS' ;
RERUN           : 'RERUN' ;
RESERVE         : 'RESERVE' ;
RESET           : 'RESET' ;
RETURN          : 'RETURN' ;
REVERSED        : 'REVERSED' ;
REWIND          : 'REWIND' ;
REWRITE         : 'REWRITE' ;
RF              : 'RF' ;
RH              : 'RH' ;
RIGHT           : 'RIGHT' ;
ROUNDED         : 'ROUNDED' ;
RUN             : 'RUN' ;
SAME            : 'SAME' ;
SD              : 'SD' ;
SEARCH          : 'SEARCH' ;
SECTION         : 'SECTION' ;
SECURITY        : 'SECURITY' ;
SEGMENT         : 'SEGMENT' ;
SEGMENT_LIMIT   : 'SEGMENT-LIMIT' ;
SELECT          : 'SELECT' ;
SEND            : 'SEND' ;
SENTENCE        : 'SENTENCE' ;
SEPARATE        : 'SEPARATE' ;
SEQUENCE        : 'SEQUENCE' ;
SEQUENTIAL      : 'SEQUENTIAL' ;
SET             : 'SET' ;
SIGN            : 'SIGN' ;
SIZE            : 'SIZE' ;
SORT            : 'SORT' ;
SORT_MERGE      : 'SORT-MERGE' ;
SOURCE          : 'SOURCE' ;
SOURCE_COMPUTER : 'SOURCE-COMPUTER' ;
SPACE           : 'SPACE' ;
SPACES          : 'SPACES' ;
SPECIAL_NAMES   : 'SPECIAL-NAMES' ;
STANDARD        : 'STANDARD' ;
STANDARD_1      : 'STANDARD-1' ;
STANDARD_2      : 'STANDARD-2' ;
START           : 'START' ;
STATUS          : 'STATUS' ;
STOP            : 'STOP' ;
STRING          : 'STRING' ;
SUB_QUEUE_1     : 'SUB-QUEUE-1' ;
SUB_QUEUE_2     : 'SUB-QUEUE-2' ;
SUB_QUEUE_3     : 'SUB-QUEUE-3' ;
SUBTRACT        : 'SUBTRACT' ;
SUM             : 'SUM' ;
SUPPRESS        : 'SUPPRESS' ;
SYMBOLIC        : 'SYMBOLIC' ;
SYNC            : 'SYNC' ;
SYNCHRONIZED    : 'SYNCHRONIZED' ;
TABLE           : 'TABLE' ;
TALLYING        : 'TALLYING' ;
TAPE            : 'TAPE' ;
TERMINAL        : 'TERMINAL' ;
TERMINATE       : 'TERMINATE' ;
TEST            : 'TEST' ;
TEXT            : 'TEXT' ;
THAN            : 'THAN' ;
THEN            : 'THEN' ;
THROUGH         : 'THROUGH' ;
THRU            : 'THRU' ;
TIME            : 'TIME' ;
TIMES           : 'TIMES' ;
TO              : 'TO' ;
TOP             : 'TOP' ;
TRAILING        : 'TRAILING' ;
TYPE            : 'TYPE' ;
UNIT            : 'UNIT' ;
UNSTRING        : 'UNSTRING' ;
UNTIL           : 'UNTIL' ;
UP              : 'UP' ;
UPON            : 'UPON' ;
USAGE           : 'USAGE' ;
USE             : 'USE' ;
USING           : 'USING' ;
VALUE           : 'VALUE' ;
VALUES          : 'VALUES' ;
VARYING         : 'VARYING' ;
WHEN            : 'WHEN' ;
WITH            : 'WITH' ;
WORDS           : 'WORDS' ;
WORKING_STORAGE : 'WORKING-STORAGE' ;
WRITE           : 'WRITE' ;
ZERO            : 'ZERO' ;
ZEROES          : 'ZEROES' ;
ZEROS           : 'ZEROS' ;

// COBOL 2023 Modern Features
JSON            : 'JSON' ;
JSON_GENERATE   : 'JSON-GENERATE' ;
JSON_PARSE      : 'JSON-PARSE' ;
XML             : 'XML' ;
XML_GENERATE    : 'XML-GENERATE' ;
XML_PARSE       : 'XML-PARSE' ;
WEB_SERVICE     : 'WEB-SERVICE' ;
REST            : 'REST' ;
HTTP            : 'HTTP' ;
HTTPS           : 'HTTPS' ;
URL             : 'URL' ;
URI             : 'URI' ;
UNICODE         : 'UNICODE' ;
UTF_8           : 'UTF-8' ;
UTF_16          : 'UTF-16' ;
EXCEPTION_OBJECT: 'EXCEPTION-OBJECT' ;
TRY             : 'TRY' ;
CATCH           : 'CATCH' ;
FINALLY         : 'FINALLY' ;
THROW           : 'THROW' ;
INTERFACE       : 'INTERFACE' ;
INTERFACE_ID    : 'INTERFACE-ID' ;
METHOD          : 'METHOD' ;
METHOD_ID       : 'METHOD-ID' ;
PROPERTY        : 'PROPERTY' ;
PROPERTY_ID     : 'PROPERTY-ID' ;
INHERITS        : 'INHERITS' ;
IMPLEMENTS      : 'IMPLEMENTS' ;
OVERRIDE        : 'OVERRIDE' ;
SUPER           : 'SUPER' ;
SELF            : 'SELF' ;
FACTORY         : 'FACTORY' ;
OBJECT          : 'OBJECT' ;
REPOSITORY      : 'REPOSITORY' ;
DELEGATE        : 'DELEGATE' ;
DELEGATE_ID     : 'DELEGATE-ID' ;
EVENT           : 'EVENT' ;
EVENT_ID        : 'EVENT-ID' ;
RAISE           : 'RAISE' ;
ENUM            : 'ENUM' ;
ENUM_ID         : 'ENUM-ID' ;
TYPEDEF         : 'TYPEDEF' ;
TYPEDEF_ID      : 'TYPEDEF-ID' ;
GENERIC         : 'GENERIC' ;
CONSTRAINED     : 'CONSTRAINED' ;
UNCONSTRAINED   : 'UNCONSTRAINED' ;

// Operators
EQUAL_SIGN      : '=' ;
GREATER_SIGN    : '>' ;
LESS_SIGN       : '<' ;
GREATER_EQUAL   : '>=' ;
LESS_EQUAL      : '<=' ;
NOT_EQUAL       : '<>' ;
PLUS_SIGN       : '+' ;
MINUS_SIGN      : '-' ;
MULTIPLY_SIGN   : '*' ;
DIVIDE_SIGN     : '/' ;
POWER_SIGN      : '**' ;

// Punctuation
DOT             : '.' ;
COMMA_CHAR      : ',' ;
SEMICOLON       : ';' ;
COLON           : ':' ;
LPAR            : '(' ;
RPAR            : ')' ;
LBRACKET        : '[' ;
RBRACKET        : ']' ;
LBRACE          : '{' ;
RBRACE          : '}' ;

// Literals
NUMERIC_LITERAL : [0-9]+ ('.' [0-9]+)? ;
STRING_LITERAL  : '"' (~["\r\n] | '""')* '"' 
                | '\'' (~['\r\n] | '\'\'')* '\'' ;
HEXADECIMAL_LITERAL : 'X"' [0-9A-Fa-f]* '"' 
                    | 'x"' [0-9A-Fa-f]* '"' ;
BOOLEAN_LITERAL : 'B"' [01]* '"' 
                | 'b"' [01]* '"' ;

// Identifiers
USER_DEFINED_WORD : [A-Za-z] [A-Za-z0-9_-]* ;
SYSTEM_NAME      : [A-Za-z] [A-Za-z0-9_-]* ;

// Comments
COMMENT_LINE    : ('*' | '/') ~[\r\n]* -> skip ;
COMMENT_BLOCK   : '/*' .*? '*/' -> skip ;

// Whitespace
WS              : [ \t\r\n]+ -> skip ;

// Continuation
CONTINUATION    : '-' [ \t]* [\r\n] -> skip ;

// ============================================================================
// PARSER RULES
// ============================================================================

// Program Structure
program
    : identificationDivision
      environmentDivision?
      dataDivision?
      procedureDivision?
      nestedPrograms*
      END PROGRAM programName DOT
    ;

// Identification Division
identificationDivision
    : IDENTIFICATION DIVISION DOT
      programIdParagraph
      (authorParagraph | installationParagraph | dateWrittenParagraph | 
       dateCompiledParagraph | securityParagraph)*
    ;

programIdParagraph
    : PROGRAM_ID DOT programName (IS? (COMMON | INITIAL | RECURSIVE))? DOT
    ;

programName
    : USER_DEFINED_WORD | STRING_LITERAL
    ;

authorParagraph
    : AUTHOR DOT commentEntry? DOT
    ;

installationParagraph
    : INSTALLATION DOT commentEntry? DOT
    ;

dateWrittenParagraph
    : DATE_WRITTEN DOT commentEntry? DOT
    ;

dateCompiledParagraph
    : DATE_COMPILED DOT commentEntry? DOT
    ;

securityParagraph
    : SECURITY DOT commentEntry? DOT
    ;

commentEntry
    : (USER_DEFINED_WORD | STRING_LITERAL | NUMERIC_LITERAL)*
    ;

// Environment Division
environmentDivision
    : ENVIRONMENT DIVISION DOT
      configurationSection?
      inputOutputSection?
    ;

configurationSection
    : CONFIGURATION SECTION DOT
      sourceComputerParagraph?
      objectComputerParagraph?
      specialNamesParagraph?
      repositoryParagraph?
    ;

sourceComputerParagraph
    : SOURCE_COMPUTER DOT computerName? (WITH? DEBUGGING MODE)? DOT
    ;

objectComputerParagraph
    : OBJECT_COMPUTER DOT computerName?
      (MEMORY SIZE? NUMERIC_LITERAL (WORDS | CHARACTERS | MODULES)?)?
      (PROGRAM COLLATING? SEQUENCE IS? alphabetName)?
      (SEGMENT_LIMIT IS? NUMERIC_LITERAL)?
      DOT
    ;

specialNamesParagraph
    : SPECIAL_NAMES DOT specialNameClause* DOT
    ;

specialNameClause
    : mnemonicNameClause
    | alphabetNameClause
    | symbolicCharacterClause
    | classNameClause
    | currencySignClause
    | decimalPointClause
    | xmlSchemaClause
    | jsonSchemaClause
    ;

// COBOL 2023 Repository Paragraph for OOP
repositoryParagraph
    : REPOSITORY DOT repositoryEntry* DOT
    ;

repositoryEntry
    : CLASS className AS? STRING_LITERAL
    | INTERFACE interfaceName AS? STRING_LITERAL
    | FUNCTION functionName AS? STRING_LITERAL
    | PROGRAM programName AS? STRING_LITERAL
    | PROPERTY propertyName AS? STRING_LITERAL
    | ENUM enumName AS? STRING_LITERAL
    | DELEGATE delegateName AS? STRING_LITERAL
    ;

inputOutputSection
    : INPUT_OUTPUT SECTION DOT
      fileControlParagraph?
      ioControlParagraph?
    ;

fileControlParagraph
    : FILE_CONTROL DOT fileControlEntry*
    ;

fileControlEntry
    : SELECT OPTIONAL? fileName
      ASSIGN TO? (dataName | STRING_LITERAL)
      (ORGANIZATION IS? (SEQUENTIAL | RELATIVE | INDEXED))?
      (ACCESS MODE? IS? (SEQUENTIAL | RANDOM | DYNAMIC))?
      (RECORD KEY IS? dataName)?
      (ALTERNATE RECORD? KEY IS? dataName (WITH? DUPLICATES)?)*
      (FILE STATUS IS? dataName)?
      (LOCK MODE IS? (MANUAL | AUTOMATIC | EXCLUSIVE))?
      DOT
    ;

ioControlParagraph
    : I_O_CONTROL DOT ioControlClause* DOT
    ;

ioControlClause
    : RERUN (ON? (fileName | dataName))? EVERY? (NUMERIC_LITERAL RECORDS | END OF? (REEL | UNIT))
    | SAME (RECORD | SORT | SORT_MERGE)? AREA? FOR? fileName+
    | MULTIPLE FILE TAPE? CONTAINS? fileName (POSITION NUMERIC_LITERAL)?
    ;

// Data Division
dataDivision
    : DATA DIVISION DOT
      fileSection?
      workingStorageSection?
      localStorageSection?
      linkageSection?
      reportSection?
      screenSection?
    ;

fileSection
    : FILE SECTION DOT fileDescriptionEntry*
    ;

fileDescriptionEntry
    : (FD | SD) fileName
      (IS? EXTERNAL)?
      (IS? GLOBAL)?
      (BLOCK CONTAINS? NUMERIC_LITERAL TO? NUMERIC_LITERAL? (RECORDS | CHARACTERS)?)?
      (RECORD (CONTAINS? NUMERIC_LITERAL TO? NUMERIC_LITERAL? CHARACTERS? | IS? VARYING IN? SIZE? FROM? NUMERIC_LITERAL TO? NUMERIC_LITERAL CHARACTERS? DEPENDING ON? dataName)?)?
      (LABEL (RECORD IS? | RECORDS ARE?) (STANDARD | OMITTED))?
      (VALUE OF? (FILE_ID | implementationName) IS? (dataName | STRING_LITERAL))*
      (DATA (RECORD IS? | RECORDS ARE?) dataName+)?
      (LINAGE IS? dataName WITH? FOOTING AT? dataName LINES? AT? TOP dataName LINES? AT? BOTTOM dataName)?
      (CODE_SET IS? alphabetName)?
      DOT
      dataDescriptionEntry*
    ;

workingStorageSection
    : WORKING_STORAGE SECTION DOT dataDescriptionEntry*
    ;

localStorageSection
    : LOCAL_STORAGE SECTION DOT dataDescriptionEntry*
    ;

linkageSection
    : LINKAGE SECTION DOT dataDescriptionEntry*
    ;

dataDescriptionEntry
    : levelNumber (dataName | FILLER)?
      (REDEFINES dataName)?
      (IS? (EXTERNAL | GLOBAL | BASED | TYPEDEF))*
      (PICTURE IS? pictureString)?
      (USAGE IS? usageClause)?
      (SIGN IS? (LEADING | TRAILING) SEPARATE CHARACTER?)?
      (OCCURS NUMERIC_LITERAL TO? NUMERIC_LITERAL? TIMES? (DEPENDING ON? dataName)? (ASCENDING | DESCENDING)? KEY? IS? dataName+ (INDEXED BY? indexName+)?)?
      (SYNCHRONIZED | SYNC (LEFT | RIGHT)?)?
      (JUSTIFIED | JUST RIGHT?)?
      (BLANK WHEN? ZERO)?
      (VALUE IS? literal+)?
      (RENAMES dataName (THROUGH | THRU) dataName)?
      DOT
    ;

// COBOL 2023 Enhanced Data Types
usageClause
    : BINARY
    | COMP | COMP_1 | COMP_2 | COMP_3 | COMP_4 | COMP_5
    | COMPUTATIONAL | COMPUTATIONAL_1 | COMPUTATIONAL_2 | COMPUTATIONAL_3 | COMPUTATIONAL_4 | COMPUTATIONAL_5
    | DISPLAY
    | INDEX
    | PACKED_DECIMAL
    | POINTER
    | PROCEDURE_POINTER
    | FUNCTION_POINTER
    | OBJECT REFERENCE className?
    | NATIONAL
    | UTF_8
    | UTF_16
    | JSON
    | XML
    ;

levelNumber
    : NUMERIC_LITERAL
    ;

pictureString
    : STRING_LITERAL
    ;

// Report Section (Enhanced for COBOL 2023)
reportSection
    : REPORT SECTION DOT reportDescriptionEntry*
    ;

reportDescriptionEntry
    : RD reportName
      (IS? GLOBAL)?
      (CODE IS? STRING_LITERAL)?
      (CONTROL IS? (FINAL | dataName+) | CONTROLS ARE? (FINAL | dataName+))?
      (PAGE LIMIT? IS? NUMERIC_LITERAL LINE? LINES? (HEADING NUMERIC_LITERAL)? (FIRST DETAIL NUMERIC_LITERAL)? (LAST DETAIL NUMERIC_LITERAL)? (FOOTING NUMERIC_LITERAL)?)?
      DOT
      reportGroupDescriptionEntry*
    ;

reportGroupDescriptionEntry
    : levelNumber dataName?
      (LINE NUMBER? IS? (NUMERIC_LITERAL | PLUS NUMERIC_LITERAL | (NEXT | PLUS) PAGE))?
      (NEXT GROUP IS? (NUMERIC_LITERAL | PLUS NUMERIC_LITERAL | NEXT PAGE))?
      (TYPE IS? (REPORT HEADING | RH | PAGE HEADING | PH | CONTROL HEADING dataName | CH dataName | DETAIL | DE | CONTROL FOOTING dataName | CF dataName | PAGE FOOTING | PF | REPORT FOOTING | RF))?
      (USAGE IS? usageClause)?
      (SIGN IS? (LEADING | TRAILING) SEPARATE CHARACTER?)?
      (JUSTIFIED | JUST RIGHT?)?
      (BLANK WHEN? ZERO)?
      (LINE NUMBER? IS? (NUMERIC_LITERAL | PLUS NUMERIC_LITERAL))?
      (COLUMN NUMBER? IS? NUMERIC_LITERAL)?
      (PICTURE IS? pictureString)?
      (SOURCE IS? identifier)?
      (VALUE IS? literal)?
      (SUM identifier+ (UPON dataName+)? (RESET ON? (dataName | FINAL))?)?
      (PRESENT WHEN? condition)?
      (GROUP INDICATE?)?
      DOT
    ;

// Screen Section (Enhanced for COBOL 2023)
screenSection
    : SCREEN SECTION DOT screenDescriptionEntry*
    ;

screenDescriptionEntry
    : levelNumber screenName?
      (BLANK (SCREEN | LINE))?
      (BELL | BEEP)?
      (BLINK)?
      (HIGHLIGHT | HIGH)?
      (LOWLIGHT | LOW)?
      (REVERSE_VIDEO | REVERSE)?
      (UNDERLINE)?
      (SIZE IS? NUMERIC_LITERAL)?
      (LINE NUMBER? IS? (NUMERIC_LITERAL | PLUS NUMERIC_LITERAL))?
      (COLUMN NUMBER? IS? (NUMERIC_LITERAL | PLUS NUMERIC_LITERAL))?
      (FOREGROUND_COLOR IS? NUMERIC_LITERAL)?
      (BACKGROUND_COLOR IS? NUMERIC_LITERAL)?
      (CONTROL IS? identifier)?
      (VALUE IS? literal)?
      (PICTURE IS? pictureString)?
      (FROM identifier | TO identifier | USING identifier)?
      (USAGE IS? usageClause)?
      (BLANK WHEN? ZERO)?
      (JUSTIFIED | JUST RIGHT?)?
      (SIGN IS? (LEADING | TRAILING) SEPARATE CHARACTER?)?
      (AUTO | AUTO_SKIP)?
      (SECURE | NO_ECHO)?
      (REQUIRED | EMPTY_CHECK)?
      (FULL | LENGTH_CHECK)?
      (PROMPT CHARACTER? IS? literal)?
      DOT
    ;

// Procedure Division
procedureDivision
    : PROCEDURE DIVISION (USING parameterList)? (RETURNING dataName)? DOT
      (DECLARATIVES DOT declarativeSection+ END DECLARATIVES DOT)?
      procedureDivisionBody
    ;

parameterList
    : parameter (COMMA? parameter)*
    ;

parameter
    : (BY? (REFERENCE | VALUE | CONTENT))? dataName
    ;

declarativeSection
    : sectionName SECTION segmentNumber? DOT
      USE statement DOT
      paragraph*
    ;

procedureDivisionBody
    : paragraph*
    | section*
    ;

section
    : sectionName SECTION segmentNumber? DOT
      paragraph*
    ;

paragraph
    : paragraphName DOT sentence*
    ;

sentence
    : statement+ DOT
    ;

// Statements (Enhanced for COBOL 2023)
statement
    : acceptStatement
    | addStatement
    | alterStatement
    | callStatement
    | cancelStatement
    | closeStatement
    | computeStatement
    | continueStatement
    | deleteStatement
    | displayStatement
    | divideStatement
    | evaluateStatement
    | exitStatement
    | goStatement
    | goToStatement
    | ifStatement
    | initializeStatement
    | inspectStatement
    | mergeStatement
    | moveStatement
    | multiplyStatement
    | openStatement
    | performStatement
    | readStatement
    | releaseStatement
    | returnStatement
    | rewriteStatement
    | searchStatement
    | setStatement
    | sortStatement
    | startStatement
    | stopStatement
    | stringStatement
    | subtractStatement
    | unstringStatement
    | writeStatement
    // COBOL 2023 Modern Statements
    | jsonGenerateStatement
    | jsonParseStatement
    | xmlGenerateStatement
    | xmlParseStatement
    | tryStatement
    | throwStatement
    | invokeStatement
    | raiseStatement
    ;

// COBOL 2023 JSON Support
jsonGenerateStatement
    : JSON_GENERATE identifier FROM identifier
      (COUNT IN? identifier)?
      (WITH? DETAIL)?
      (NAME OF? identifier IS? identifier)*
      (SUPPRESS identifier)*
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      END_JSON_GENERATE?
    ;

jsonParseStatement
    : JSON_PARSE identifier INTO identifier
      (WITH? DETAIL)?
      (NAME OF? identifier IS? identifier)*
      (SUPPRESS identifier)*
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      END_JSON_PARSE?
    ;

// COBOL 2023 XML Support  
xmlGenerateStatement
    : XML_GENERATE identifier FROM identifier
      (COUNT IN? identifier)?
      (WITH? (ENCODING | XML_DECLARATION | ATTRIBUTES | NAMESPACE | NAMESPACE_PREFIX | TEXT | ELEMENT_NAMES | CONTENT | TYPE))*
      (NAME OF? identifier IS? identifier)*
      (SUPPRESS identifier)*
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      END_XML_GENERATE?
    ;

xmlParseStatement
    : XML_PARSE identifier
      (PROCESSING PROCEDURE IS? procedureName (THROUGH | THRU procedureName)?)?
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      END_XML_PARSE?
    ;

// COBOL 2023 Exception Handling
tryStatement
    : TRY
      statement+
      catchClause*
      finallyClause?
      END_TRY
    ;

catchClause
    : CATCH exceptionClass
      statement+
    ;

finallyClause
    : FINALLY
      statement+
    ;

throwStatement
    : THROW exceptionObject
    ;

// COBOL 2023 Object-Oriented Programming
invokeStatement
    : INVOKE (identifier | SELF | SUPER) STRING_LITERAL
      (USING parameter+)?
      (RETURNING identifier)?
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      END_INVOKE?
    ;

raiseStatement
    : RAISE EVENT eventName
      (USING parameter+)?
    ;

// Traditional COBOL Statements (Enhanced)
acceptStatement
    : ACCEPT identifier (FROM (DATE | DAY | DAY_OF_WEEK | TIME | CONSOLE | SYSIN | ENVIRONMENT STRING_LITERAL))?
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      END_ACCEPT?
    ;

addStatement
    : ADD (identifier | literal)+ TO identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_ADD?
    | ADD (identifier | literal)+ (identifier | literal)+ GIVING identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_ADD?
    | ADD CORRESPONDING identifier TO identifier (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_ADD?
    ;

callStatement
    : CALL (identifier | STRING_LITERAL)
      (USING parameter+)?
      (RETURNING identifier)?
      (ON EXCEPTION imperativeStatement)?
      (NOT ON? EXCEPTION imperativeStatement)?
      (ON OVERFLOW imperativeStatement)?
      (NOT ON? OVERFLOW imperativeStatement)?
      END_CALL?
    ;

computeStatement
    : COMPUTE identifier+ (ROUNDED)? EQUAL_SIGN arithmeticExpression
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_COMPUTE?
    ;

evaluateStatement
    : EVALUATE subject (ALSO subject)*
      whenClause+
      (WHEN OTHER imperativeStatement)?
      END_EVALUATE
    ;

whenClause
    : WHEN selectionObject (ALSO selectionObject)* imperativeStatement
    ;

ifStatement
    : IF condition THEN?
      (statement+ | NEXT SENTENCE)
      (ELSE (statement+ | NEXT SENTENCE))?
      END_IF?
    ;

performStatement
    : PERFORM (procedureName (THROUGH | THRU procedureName)?)?
      (NUMERIC_LITERAL TIMES)?
      (UNTIL condition)?
      (VARYING identifier FROM (identifier | literal) BY (identifier | literal) UNTIL condition (AFTER identifier FROM (identifier | literal) BY (identifier | literal) UNTIL condition)*)?
      (WITH? TEST (BEFORE | AFTER))?
      (statement+ END_PERFORM)?
    ;

// Expressions and Conditions
arithmeticExpression
    : term ((PLUS_SIGN | MINUS_SIGN) term)*
    ;

term
    : factor ((MULTIPLY_SIGN | DIVIDE_SIGN) factor)*
    ;

factor
    : (PLUS_SIGN | MINUS_SIGN)? primary (POWER_SIGN primary)?
    ;

primary
    : identifier
    | literal
    | LPAR arithmeticExpression RPAR
    | functionCall
    ;

functionCall
    : FUNCTION functionName (LPAR argument (COMMA argument)* RPAR)?
    ;

condition
    : simpleCondition ((AND | OR) simpleCondition)*
    ;

simpleCondition
    : NOT? (relationCondition | classCondition | signCondition)
    | LPAR condition RPAR
    ;

relationCondition
    : identifier (IS? (NOT? (EQUAL TO? | GREATER THAN? | LESS THAN? | GREATER THAN? OR EQUAL TO? | LESS THAN? OR EQUAL TO?))) (identifier | literal)
    ;

classCondition
    : identifier IS? NOT? (NUMERIC | ALPHABETIC | ALPHABETIC_LOWER | ALPHABETIC_UPPER | ALPHANUMERIC | ALPHANUMERIC_EDITED | NUMERIC_EDITED | className)
    ;

signCondition
    : identifier IS? NOT? (POSITIVE | NEGATIVE | ZERO)
    ;

// COBOL 2023 Class Definitions
classDefinition
    : CLASS_ID DOT className (INHERITS className)? DOT
      (ENVIRONMENT DIVISION DOT
       configurationSection?)?
      (DATA DIVISION DOT
       workingStorageSection?
       objectSection?)?
      (PROCEDURE DIVISION DOT
       methodDefinition*)?
      END CLASS className DOT
    ;

objectSection
    : OBJECT SECTION DOT dataDescriptionEntry*
    ;

methodDefinition
    : METHOD_ID DOT methodName DOT
      (DATA DIVISION DOT
       workingStorageSection?
       linkageSection?)?
      (PROCEDURE DIVISION (USING parameterList)? (RETURNING dataName)? DOT
       procedureDivisionBody)?
      END METHOD methodName DOT
    ;

// COBOL 2023 Interface Definitions
interfaceDefinition
    : INTERFACE_ID DOT interfaceName DOT
      (PROCEDURE DIVISION DOT
       methodPrototype*)?
      END INTERFACE interfaceName DOT
    ;

methodPrototype
    : METHOD_ID DOT methodName (USING parameterList)? (RETURNING dataName)? DOT
    ;

// Names and Identifiers
identifier
    : qualifiedDataName
    | functionCall
    | specialRegister
    ;

qualifiedDataName
    : dataName (OF | IN dataName)*
    | dataName LPAR subscript (COMMA subscript)* RPAR (OF | IN dataName)*
    ;

subscript
    : arithmeticExpression
    | ALL
    ;

specialRegister
    : ADDRESS OF? dataName
    | LENGTH OF? dataName
    | LINAGE_COUNTER
    | LINE_COUNTER
    | PAGE_COUNTER
    | RETURN_CODE
    | SHIFT_IN
    | SHIFT_OUT
    | SORT_CONTROL
    | SORT_CORE_SIZE
    | SORT_FILE_SIZE
    | SORT_MESSAGE
    | SORT_MODE_SIZE
    | SORT_RETURN
    | TALLY
    | WHEN_COMPILED
    | JSON_CODE
    | JSON_STATUS
    | XML_CODE
    | XML_EVENT
    | XML_INFORMATION
    | XML_NAMESPACE
    | XML_NAMESPACE_PREFIX
    | XML_NNAMESPACE
    | XML_NNAMESPACE_PREFIX
    | XML_NTEXT
    | XML_TEXT
    ;

literal
    : NUMERIC_LITERAL
    | STRING_LITERAL
    | HEXADECIMAL_LITERAL
    | BOOLEAN_LITERAL
    | figurativeConstant
    ;

figurativeConstant
    : ZERO | ZEROS | ZEROES
    | SPACE | SPACES
    | HIGH_VALUE | HIGH_VALUES
    | LOW_VALUE | LOW_VALUES
    | QUOTE | QUOTES
    | NULL | NULLS
    | ALL literal
    ;

// Names
dataName            : USER_DEFINED_WORD ;
fileName            : USER_DEFINED_WORD ;
procedureName       : USER_DEFINED_WORD | paragraphName | sectionName ;
paragraphName       : USER_DEFINED_WORD ;
sectionName         : USER_DEFINED_WORD ;
computerName        : SYSTEM_NAME ;
implementationName  : SYSTEM_NAME ;
alphabetName        : USER_DEFINED_WORD ;
className           : USER_DEFINED_WORD ;
interfaceName       : USER_DEFINED_WORD ;
methodName          : USER_DEFINED_WORD ;
propertyName        : USER_DEFINED_WORD ;
eventName           : USER_DEFINED_WORD ;
enumName            : USER_DEFINED_WORD ;
delegateName        : USER_DEFINED_WORD ;
functionName        : USER_DEFINED_WORD ;
indexName           : USER_DEFINED_WORD ;
mnemonicName        : USER_DEFINED_WORD ;
recordName          : USER_DEFINED_WORD ;
reportName          : USER_DEFINED_WORD ;
screenName          : USER_DEFINED_WORD ;
symbolicCharacter   : USER_DEFINED_WORD ;
textName            : USER_DEFINED_WORD ;
exceptionClass      : USER_DEFINED_WORD ;
exceptionObject     : USER_DEFINED_WORD ;

// Additional clauses and constructs
mnemonicNameClause
    : implementationName IS? mnemonicName
    | implementationName IS? mnemonicName (STATUS IS? condition)?
    ;

alphabetNameClause
    : ALPHABET alphabetName IS? (STANDARD_1 | STANDARD_2 | NATIVE | implementationName | literalRange+)
    ;

literalRange
    : literal (THROUGH | THRU literal)?
    | literal ALSO literal+
    ;

symbolicCharacterClause
    : SYMBOLIC CHARACTERS? symbolicCharacter+ (IS | ARE)? NUMERIC_LITERAL+ (IN alphabetName)?
    ;

classNameClause
    : CLASS className IS? literalRange+
    ;

currencySignClause
    : CURRENCY SIGN? IS? literal (WITH? PICTURE SYMBOL literal)?
    ;

decimalPointClause
    : DECIMAL_POINT IS? COMMA
    ;

xmlSchemaClause
    : XML_SCHEMA STRING_LITERAL
    ;

jsonSchemaClause
    : JSON_SCHEMA STRING_LITERAL
    ;

segmentNumber
    : NUMERIC_LITERAL
    ;

subject
    : identifier | literal | TRUE | FALSE
    ;

selectionObject
    : ANY
    | condition
    | TRUE | FALSE
    | NOT? (identifier | literal)
    | NOT? literalRange
    ;

argument
    : identifier | literal
    ;

imperativeStatement
    : statement+
    ;

// Nested Programs (COBOL 2023 Enhancement)
nestedPrograms
    : program
    | classDefinition
    | interfaceDefinition
    ;

// Additional missing statement implementations
alterStatement
    : ALTER procedureName TO PROCEED? TO procedureName (COMMA procedureName TO PROCEED? TO procedureName)*
    ;

cancelStatement
    : CANCEL (identifier | STRING_LITERAL)+
    ;

closeStatement
    : CLOSE fileName (WITH? (NO REWIND | LOCK | REMOVAL | REEL | UNIT))*
    ;

continueStatement
    : CONTINUE
    ;

deleteStatement
    : DELETE fileName RECORD?
      (INVALID KEY? imperativeStatement)?
      (NOT INVALID? KEY imperativeStatement)?
      END_DELETE?
    ;

displayStatement
    : DISPLAY (identifier | literal)+ (UPON (mnemonicName | CONSOLE | SYSPUNCH | SYSOUT))?
      (WITH? NO ADVANCING)?
    ;

divideStatement
    : DIVIDE (identifier | literal) INTO identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_DIVIDE?
    | DIVIDE (identifier | literal) BY (identifier | literal) GIVING identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_DIVIDE?
    | DIVIDE (identifier | literal) INTO (identifier | literal) GIVING identifier (ROUNDED)? REMAINDER identifier
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_DIVIDE?
    ;

exitStatement
    : EXIT (PROGRAM | METHOD | FUNCTION | PARAGRAPH | SECTION | PERFORM CYCLE?)?
    ;

goStatement
    : GO TO? procedureName+ DEPENDING ON? identifier
    ;

goToStatement
    : GO TO? procedureName
    ;

initializeStatement
    : INITIALIZE identifier+ (REPLACING (ALPHABETIC | ALPHANUMERIC | ALPHANUMERIC_EDITED | NUMERIC | NUMERIC_EDITED | DBCS | EGCS) DATA? BY (identifier | literal))*
    ;

inspectStatement
    : INSPECT identifier (TALLYING identifier FOR (ALL | LEADING | CHARACTERS) (identifier | literal) (BEFORE | AFTER) INITIAL? (identifier | literal)?)*
      (REPLACING (ALL | LEADING | FIRST) (identifier | literal) BY (identifier | literal) (BEFORE | AFTER) INITIAL? (identifier | literal)?)*
      (CONVERTING (identifier | literal) TO (identifier | literal) (BEFORE | AFTER) INITIAL? (identifier | literal)?)?
    ;

mergeStatement
    : MERGE fileName (ASCENDING | DESCENDING)? KEY? dataName+ (COLLATING? SEQUENCE IS? alphabetName)?
      USING fileName+
      (OUTPUT PROCEDURE IS? procedureName (THROUGH | THRU procedureName)?)?
      (GIVING fileName+)?
    ;

moveStatement
    : MOVE (identifier | literal | ALL literal) TO identifier+
    | MOVE CORRESPONDING identifier TO identifier+
    ;

multiplyStatement
    : MULTIPLY (identifier | literal) BY identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_MULTIPLY?
    | MULTIPLY (identifier | literal) BY (identifier | literal) GIVING identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_MULTIPLY?
    ;

openStatement
    : OPEN (INPUT fileName (REVERSED | WITH? NO REWIND)?)+ 
    | OPEN (OUTPUT fileName (WITH? NO REWIND)?)+
    | OPEN (I_O fileName)+
    | OPEN (EXTEND fileName)+
    ;

readStatement
    : READ fileName RECORD? (INTO identifier)?
      (AT? END imperativeStatement)?
      (NOT AT? END imperativeStatement)?
      (INVALID KEY? imperativeStatement)?
      (NOT INVALID? KEY imperativeStatement)?
      END_READ?
    ;

releaseStatement
    : RELEASE recordName (FROM identifier)?
    ;

returnStatement
    : RETURN fileName RECORD? (INTO identifier)?
      AT? END imperativeStatement
      (NOT AT? END imperativeStatement)?
      END_RETURN?
    ;

rewriteStatement
    : REWRITE recordName (FROM identifier)?
      (INVALID KEY? imperativeStatement)?
      (NOT INVALID? KEY imperativeStatement)?
      END_REWRITE?
    ;

searchStatement
    : SEARCH identifier (VARYING identifier)?
      (AT? END imperativeStatement)?
      (WHEN condition (statement+ | NEXT SENTENCE))+
      END_SEARCH?
    | SEARCH ALL identifier
      (AT? END imperativeStatement)?
      WHEN (dataName (IS? (EQUAL TO? | EQUAL_SIGN)) (identifier | literal) (AND dataName (IS? (EQUAL TO? | EQUAL_SIGN)) (identifier | literal))*)
      (statement+ | NEXT SENTENCE)
      END_SEARCH?
    ;

setStatement
    : SET (identifier+ TO (identifier | literal | TRUE | FALSE))+
    | SET (identifier+ (UP | DOWN) BY (identifier | literal))+
    | SET (ADDRESS OF? identifier+ TO (identifier | NULL))+
    ;

sortStatement
    : SORT fileName (ASCENDING | DESCENDING)? KEY? dataName+ (COLLATING? SEQUENCE IS? alphabetName)?
      (INPUT PROCEDURE IS? procedureName (THROUGH | THRU procedureName)?)?
      (USING fileName+)?
      (OUTPUT PROCEDURE IS? procedureName (THROUGH | THRU procedureName)?)?
      (GIVING fileName+)?
    ;

startStatement
    : START fileName KEY? (IS? (EQUAL TO? | EQUAL_SIGN | GREATER THAN? | GREATER_SIGN | NOT LESS THAN? | NOT LESS_SIGN | GREATER THAN? OR EQUAL TO? | GREATER_EQUAL)) dataName
      (INVALID KEY? imperativeStatement)?
      (NOT INVALID? KEY imperativeStatement)?
      END_START?
    ;

stopStatement
    : STOP RUN (RETURNING | GIVING)? (identifier | literal)?
    | STOP STRING_LITERAL
    ;

stringStatement
    : STRING (identifier | literal)+ DELIMITED BY? (identifier | literal | SIZE)
      INTO identifier
      (WITH? POINTER identifier)?
      (ON OVERFLOW imperativeStatement)?
      (NOT ON? OVERFLOW imperativeStatement)?
      END_STRING?
    ;

subtractStatement
    : SUBTRACT (identifier | literal)+ FROM identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_SUBTRACT?
    | SUBTRACT (identifier | literal)+ FROM (identifier | literal) GIVING identifier+ (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_SUBTRACT?
    | SUBTRACT CORRESPONDING identifier FROM identifier (ROUNDED)?
      (SIZE ERROR imperativeStatement)?
      (NOT SIZE? ERROR imperativeStatement)?
      END_SUBTRACT?
    ;

unstringStatement
    : UNSTRING identifier
      DELIMITED BY? (ALL? (identifier | literal))+
      INTO identifier (DELIMITER IN? identifier)? (COUNT IN? identifier)?
      (WITH? POINTER identifier)?
      (TALLYING IN? identifier)?
      (ON OVERFLOW imperativeStatement)?
      (NOT ON? OVERFLOW imperativeStatement)?
      END_UNSTRING?
    ;

writeStatement
    : WRITE recordName (FROM identifier)?
      ((BEFORE | AFTER) ADVANCING? ((identifier | literal) (LINE | LINES)? | mnemonicName | PAGE))?
      (AT? (END_OF_PAGE | EOP) imperativeStatement)?
      (NOT AT? (END_OF_PAGE | EOP) imperativeStatement)?
      (INVALID KEY? imperativeStatement)?
      (NOT INVALID? KEY imperativeStatement)?
      END_WRITE?
    ;

// Additional tokens for COBOL 2023
LOCAL_STORAGE       : 'LOCAL-STORAGE' ;
END_JSON_GENERATE   : 'END-JSON-GENERATE' ;
END_JSON_PARSE      : 'END-JSON-PARSE' ;
END_XML_GENERATE    : 'END-XML-GENERATE' ;
END_XML_PARSE       : 'END-XML-PARSE' ;
END_TRY             : 'END-TRY' ;
END_INVOKE          : 'END-INVOKE' ;
PROCEDURE_POINTER   : 'PROCEDURE-POINTER' ;
FUNCTION_POINTER    : 'FUNCTION-POINTER' ;
RETURN_CODE         : 'RETURN-CODE' ;
SHIFT_IN            : 'SHIFT-IN' ;
SHIFT_OUT           : 'SHIFT-OUT' ;
SORT_CONTROL        : 'SORT-CONTROL' ;
SORT_CORE_SIZE      : 'SORT-CORE-SIZE' ;
SORT_FILE_SIZE      : 'SORT-FILE-SIZE' ;
SORT_MESSAGE        : 'SORT-MESSAGE' ;
SORT_MODE_SIZE      : 'SORT-MODE-SIZE' ;
SORT_RETURN         : 'SORT-RETURN' ;
TALLY               : 'TALLY' ;
WHEN_COMPILED       : 'WHEN-COMPILED' ;
JSON_CODE           : 'JSON-CODE' ;
JSON_STATUS         : 'JSON-STATUS' ;
XML_CODE            : 'XML-CODE' ;
XML_EVENT           : 'XML-EVENT' ;
XML_INFORMATION     : 'XML-INFORMATION' ;
XML_NAMESPACE       : 'XML-NAMESPACE' ;
XML_NAMESPACE_PREFIX: 'XML-NAMESPACE-PREFIX' ;
XML_NNAMESPACE      : 'XML-NNAMESPACE' ;
XML_NNAMESPACE_PREFIX: 'XML-NNAMESPACE-PREFIX' ;
XML_NTEXT           : 'XML-NTEXT' ;
XML_TEXT            : 'XML-TEXT' ;
TRUE                : 'TRUE' ;
FALSE               : 'FALSE' ;
NATIONAL            : 'NATIONAL' ;
ENCODING            : 'ENCODING' ;
XML_DECLARATION     : 'XML-DECLARATION' ;
ATTRIBUTES          : 'ATTRIBUTES' ;
NAMESPACE           : 'NAMESPACE' ;
NAMESPACE_PREFIX    : 'NAMESPACE-PREFIX' ;
ELEMENT_NAMES       : 'ELEMENT-NAMES' ;
PROCESSING          : 'PROCESSING' ;
BEEP                : 'BEEP' ;
BLINK               : 'BLINK' ;
REVERSE_VIDEO       : 'REVERSE-VIDEO' ;
UNDERLINE           : 'UNDERLINE' ;
FOREGROUND_COLOR    : 'FOREGROUND-COLOR' ;
BACKGROUND_COLOR    : 'BACKGROUND-COLOR' ;
AUTO_SKIP           : 'AUTO-SKIP' ;
NO_ECHO             : 'NO-ECHO' ;
EMPTY_CHECK         : 'EMPTY-CHECK' ;
LENGTH_CHECK        : 'LENGTH-CHECK' ;
PROMPT              : 'PROMPT' ;
CONSOLE             : 'CONSOLE' ;
SYSIN               : 'SYSIN' ;
SYSPUNCH            : 'SYSPUNCH' ;
SYSOUT              : 'SYSOUT' ;
CYCLE               : 'CYCLE' ;
DBCS                : 'DBCS' ;
EGCS                : 'EGCS' ;
MANUAL              : 'MANUAL' ;
AUTOMATIC           : 'AUTOMATIC' ;
EXCLUSIVE           : 'EXCLUSIVE' ;
REEL                : 'REEL' ;
UNIT                : 'UNIT' ;
REMOVAL             : 'REMOVAL' ;
REWIND              : 'REWIND' ;
LOCK                : 'LOCK' ;
REVERSED            : 'REVERSED' ;
ADVANCING           : 'ADVANCING' ;

