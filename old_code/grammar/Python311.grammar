/*
 * Python 3.11 Grammar Specification
 * 
 * This grammar is designed for parsing the Python 3.11 programming language and is suitable for a grammar marketplace.
 * It covers the full language specification, including modern features like structural pattern matching, exception groups,
 * enhanced error messages, task groups, TOML support, and improved type hints. This grammar is based on the 
 * official Python 3.11 specification and includes all language features up to Python 3.11.8.
 */

TokenSplitter: Space
Keywords: False, None, True, and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield, match, case, type

<file_input> ::= <statements>? NEWLINE* ENDMARKER

<interactive_input> ::= <statement_newline>

<eval_input> ::= <testlist> NEWLINE* ENDMARKER

<decorator> ::= @ <dotted_name> ( ( <arglist> ) )? NEWLINE

<decorators> ::= <decorator>+

<decorated> ::= <decorators> ( <classdef> | <funcdef> | <async_funcdef> )

<async_funcdef> ::= async <funcdef>

<funcdef> ::= def NAME <parameters> ( -> <test> )? : <suite>

<parameters> ::= ( <typedargslist>? )

<typedargslist> ::= ( <tfpdef> ( = <test> )? ( , <tfpdef> ( = <test> )? )* ( , ( <star_args> | <kwargs> )? )? | <star_args> | <kwargs> )

<star_args> ::= * <tfpdef>? ( , <tfpdef> ( = <test> )? )* ( , <kwargs> )?

<kwargs> ::= ** <tfpdef>

<tfpdef> ::= NAME ( : <test> )?

<varargslist> ::= ( <vfpdef> ( = <test> )? ( , <vfpdef> ( = <test> )? )* ( , ( <star_vargs> | <vkwargs> )? )? | <star_vargs> | <vkwargs> )

<star_vargs> ::= * <vfpdef>? ( , <vfpdef> ( = <test> )? )* ( , <vkwargs> )?

<vkwargs> ::= ** <vfpdef>

<vfpdef> ::= NAME

<stmt> ::= <simple_stmt> | <compound_stmt>

<simple_stmt> ::= <small_stmt> ( ; <small_stmt> )* ;? NEWLINE

<small_stmt> ::= ( <expr_stmt> | <del_stmt> | <pass_stmt> | <flow_stmt> | <import_stmt> | <global_stmt> | <nonlocal_stmt> | <assert_stmt> | <type_stmt> )

<expr_stmt> ::= <testlist_star_expr> ( <annassign> | <augassign> ( <yield_expr> | <testlist> ) | ( = ( <yield_expr> | <testlist_star_expr> ) )* )

<annassign> ::= : <test> ( = ( <yield_expr> | <testlist> ) )?

<testlist_star_expr> ::= ( <test> | <star_expr> ) ( , ( <test> | <star_expr> ) )* ,?

<augassign> ::= ( += | -= | *= | @= | /= | %= | &= | |= | ^= | <<= | >>= | **= | //= )

<del_stmt> ::= del <exprlist>

<pass_stmt> ::= pass

<flow_stmt> ::= <break_stmt> | <continue_stmt> | <return_stmt> | <raise_stmt> | <yield_stmt>

<break_stmt> ::= break

<continue_stmt> ::= continue

<return_stmt> ::= return <testlist>?

<yield_stmt> ::= <yield_expr>

<raise_stmt> ::= raise ( <test> ( from <test> )? )?

<import_stmt> ::= <import_name> | <import_from>

<import_name> ::= import <dotted_as_names>

<import_from> ::= from ( <dotted_name> | . * | ( . + <dotted_name> ) ) import ( * | ( <import_as_names> ) | <import_as_names> )

<import_as_name> ::= NAME ( as NAME )?

<dotted_as_name> ::= <dotted_name> ( as NAME )?

<import_as_names> ::= <import_as_name> ( , <import_as_name> )* ,?

<dotted_as_names> ::= <dotted_as_name> ( , <dotted_as_name> )*

<dotted_name> ::= NAME ( . NAME )*

<global_stmt> ::= global NAME ( , NAME )*

<nonlocal_stmt> ::= nonlocal NAME ( , NAME )*

<assert_stmt> ::= assert <test> ( , <test> )?

<type_stmt> ::= type NAME <type_params>? = <test>

<type_params> ::= [ <type_param> ( , <type_param> )* ,? ]

<type_param> ::= <type_var> | <type_var_tuple> | <param_spec>

<type_var> ::= NAME ( : <test> )?

<type_var_tuple> ::= * NAME ( : <test> )?

<param_spec> ::= ** NAME ( : <test> )?

<compound_stmt> ::= <if_stmt> | <while_stmt> | <for_stmt> | <try_stmt> | <with_stmt> | <funcdef> | <classdef> | <decorated> | <async_stmt> | <match_stmt>

<async_stmt> ::= async ( <funcdef> | <with_stmt> | <for_stmt> )

<if_stmt> ::= if <test> : <suite> ( elif <test> : <suite> )* ( else : <suite> )?

<while_stmt> ::= while <test> : <suite> ( else : <suite> )?

<for_stmt> ::= for <exprlist> in <testlist> : <suite> ( else : <suite> )?

<try_stmt> ::= ( try : <suite> ( ( <except_clause> : <suite> )+ ( else : <suite> )? ( finally : <suite> )? | finally : <suite> ) | try : <suite> <except_star_clause>+ ( else : <suite> )? ( finally : <suite> )? )

<with_stmt> ::= with <with_item> ( , <with_item> )* : <suite>

<with_item> ::= <test> ( as <expr> )?

<except_clause> ::= except ( <test> ( as NAME )? )?

<except_star_clause> ::= except* <test> ( as NAME )?

<suite> ::= <simple_stmt> | NEWLINE INDENT <stmt>+ DEDENT

<match_stmt> ::= match <subject_expr> : NEWLINE INDENT <case_block>+ DEDENT

<subject_expr> ::= <star_named_expression> ( , <star_named_expressions> )?

<star_named_expressions> ::= <star_named_expression> ( , <star_named_expression> )* ,?

<star_named_expression> ::= * <expr> | <named_expression>

<case_block> ::= case <patterns> <guard>? : <block>

<guard> ::= if <named_expression>

<patterns> ::= <open_sequence_pattern> | <pattern>

<pattern> ::= <as_pattern> | <or_pattern>

<as_pattern> ::= <or_pattern> as <pattern_capture_target>

<or_pattern> ::= <closed_pattern> ( | <closed_pattern> )*

<closed_pattern> ::= <literal_pattern> | <capture_pattern> | <wildcard_pattern> | <value_pattern> | <group_pattern> | <sequence_pattern> | <mapping_pattern> | <class_pattern>

<literal_pattern> ::= <signed_number> | <complex_number> | <strings> | None | True | False

<literal_expr> ::= <signed_number> | <complex_number> | <strings> | None | True | False

<complex_number> ::= <signed_real_number> + <imaginary_number> | <signed_real_number> - <imaginary_number>

<signed_number> ::= NUMBER | - NUMBER

<signed_real_number> ::= <real_number> | - <real_number>

<real_number> ::= NUMBER

<imaginary_number> ::= NUMBER

<capture_pattern> ::= <pattern_capture_target>

<pattern_capture_target> ::= ! ( _ )

<wildcard_pattern> ::= _

<value_pattern> ::= <attr> | <name_or_attr> . NAME | <name_or_attr> . NAME . NAME

<attr> ::= <name_or_attr> . NAME

<name_or_attr> ::= <attr> | NAME

<group_pattern> ::= ( <pattern> )

<sequence_pattern> ::= [ <maybe_sequence_pattern>? ] | ( <open_sequence_pattern>? )

<open_sequence_pattern> ::= <maybe_star_pattern> , <maybe_sequence_pattern>?

<maybe_sequence_pattern> ::= <maybe_star_pattern> ( , <maybe_star_pattern> )* ,?

<maybe_star_pattern> ::= <star_pattern> | <pattern>

<star_pattern> ::= * <pattern_capture_target> | * <wildcard_pattern>

<mapping_pattern> ::= { } | { <double_star_pattern> ,? } | { <items_pattern> , <double_star_pattern> ,? } | { <items_pattern> ,? }

<items_pattern> ::= <key_value_pattern> ( , <key_value_pattern> )*

<key_value_pattern> ::= ( <literal_expr> | <attr> ) : <pattern>

<double_star_pattern> ::= ** <pattern_capture_target>

<class_pattern> ::= <name_or_attr> ( ) | <name_or_attr> ( <positional_patterns> ,? ) | <name_or_attr> ( <keyword_patterns> ,? ) | <name_or_attr> ( <positional_patterns> , <keyword_patterns> ,? )

<positional_patterns> ::= <pattern> ( , <pattern> )*

<keyword_patterns> ::= <keyword_pattern> ( , <keyword_pattern> )*

<keyword_pattern> ::= NAME = <pattern>

<block> ::= <simple_stmt> | NEWLINE INDENT <statements> DEDENT

<statements> ::= <statement>+

<statement> ::= <compound_stmt> | <simple_stmt>

<statement_newline> ::= <compound_stmt> NEWLINE | <simple_stmt> | NEWLINE

<test> ::= <or_test> ( if <or_test> else <test> )? | <lambdef>

<test_nocond> ::= <or_test> | <lambdef_nocond>

<lambdef> ::= lambda <varargslist>? : <test>

<lambdef_nocond> ::= lambda <varargslist>? : <test_nocond>

<or_test> ::= <and_test> ( or <and_test> )*

<and_test> ::= <not_test> ( and <not_test> )*

<not_test> ::= not <not_test> | <comparison>

<comparison> ::= <expr> ( <comp_op> <expr> )*

<comp_op> ::= < | > | == | >= | <= | <> | != | in | not in | is | is not

<star_expr> ::= * <expr>

<expr> ::= <xor_expr> ( | <xor_expr> )*

<xor_expr> ::= <and_expr> ( ^ <and_expr> )*

<and_expr> ::= <shift_expr> ( & <shift_expr> )*

<shift_expr> ::= <arith_expr> ( ( << | >> ) <arith_expr> )*

<arith_expr> ::= <term> ( ( + | - ) <term> )*

<term> ::= <factor> ( ( * | @ | / | % | // ) <factor> )*

<factor> ::= ( + | - | ~ ) <factor> | <power>

<power> ::= <atom_expr> ( ** <factor> )?

<atom_expr> ::= <atom> <trailer>*

<atom> ::= ( ( <yield_expr> | <testlist_comp> ) ) | [ <listmaker>? ] | { <dictorsetmaker>? } | ` <testlist1> ` | NAME | NUMBER | <strings> | ... | None | True | False

<testlist_comp> ::= ( <test> | <star_expr> ) ( <comp_for> | ( , ( <test> | <star_expr> ) )* ,? )

<trailer> ::= ( <arglist>? ) | [ <subscriptlist> ] | . NAME

<subscriptlist> ::= <subscript> ( , <subscript> )* ,?

<subscript> ::= <test> | <test>? : <test>? <sliceop>?

<sliceop> ::= : <test>?

<exprlist> ::= ( <expr> | <star_expr> ) ( , ( <expr> | <star_expr> ) )* ,?

<testlist> ::= <test> ( , <test> )* ,?

<dictorsetmaker> ::= ( ( ( <test> : <test> | ** <expr> ) ( <comp_for> | ( , ( <test> : <test> | ** <expr> ) )* ,? ) ) | ( ( <test> | <star_expr> ) ( <comp_for> | ( , ( <test> | <star_expr> ) )* ,? ) ) )

<classdef> ::= class NAME ( ( <arglist> ) )? : <suite>

<arglist> ::= <argument> ( , <argument> )* ,?

<argument> ::= ( <test> <comp_for>? | <test> = <test> | ** <test> | * <test> )

<comp_iter> ::= <comp_for> | <comp_if>

<sync_comp_for> ::= for <exprlist> in <or_test> <comp_iter>?

<comp_for> ::= <async_comp_for> | <sync_comp_for>

<async_comp_for> ::= async <sync_comp_for>

<comp_if> ::= if <test_nocond> <comp_iter>?

<encoding_decl> ::= NAME

<yield_expr> ::= yield <yield_arg>?

<yield_arg> ::= from <test> | <testlist>

<strings> ::= <string>+

<string> ::= STRING | BYTES

<listmaker> ::= ( <test> | <star_expr> ) ( <comp_for> | ( , ( <test> | <star_expr> ) )* ,? )

<testlist1> ::= <test> ( , <test> )*

<named_expression> ::= <assignment_expression> | <expression>

<assignment_expression> ::= NAME := <expression>

<expression> ::= <conditional_expression> | <lambda_expr>

<lambda_expr> ::= lambda <parameter_list>? : <expression>

<conditional_expression> ::= <or_expr> ( if <or_expr> else <expression> )?

<or_expr> ::= <and_expr> ( or <and_expr> )*

<and_expr> ::= <not_expr> ( and <not_expr> )*

<not_expr> ::= not <not_expr> | <comparison_expr>

<comparison_expr> ::= <bitwise_or> ( <compare_op_bitwise_or_pair> )*

<compare_op_bitwise_or_pair> ::= <eq_bitwise_or> | <noteq_bitwise_or> | <lte_bitwise_or> | <lt_bitwise_or> | <gte_bitwise_or> | <gt_bitwise_or> | <notin_bitwise_or> | <in_bitwise_or> | <isnot_bitwise_or> | <is_bitwise_or>

<eq_bitwise_or> ::= == <bitwise_or>

<noteq_bitwise_or> ::= != <bitwise_or>

<lte_bitwise_or> ::= <= <bitwise_or>

<lt_bitwise_or> ::= < <bitwise_or>

<gte_bitwise_or> ::= >= <bitwise_or>

<gt_bitwise_or> ::= > <bitwise_or>

<notin_bitwise_or> ::= not in <bitwise_or>

<in_bitwise_or> ::= in <bitwise_or>

<isnot_bitwise_or> ::= is not <bitwise_or>

<is_bitwise_or> ::= is <bitwise_or>

<bitwise_or> ::= <bitwise_xor> ( | <bitwise_xor> )*

<bitwise_xor> ::= <bitwise_and> ( ^ <bitwise_and> )*

<bitwise_and> ::= <shift_expr> ( & <shift_expr> )*

<shift_expr> ::= <sum> ( ( << | >> ) <sum> )*

<sum> ::= <term> ( ( + | - ) <term> )*

<term> ::= <factor> ( ( * | / | // | % | @ ) <factor> )*

<factor> ::= + <factor> | - <factor> | ~ <factor> | <power>

<power> ::= <await_primary> ( ** <factor> )?

<await_primary> ::= await <primary> | <primary>

<primary> ::= <atom> | <attributeref> | <subscription> | <slicing> | <call>

<atom> ::= <identifier> | <literal> | <enclosure>

<identifier> ::= NAME

<literal> ::= <stringliteral> | <bytesliteral> | <integer> | <floatnumber> | <imagnumber>

<stringliteral> ::= <stringprefix>? ( <shortstring> | <longstring> )

<stringprefix> ::= r | u | R | U | f | F | fr | Fr | fR | FR | rf | rF | Rf | RF

<shortstring> ::= ' <shortstringitem>* ' | " <shortstringitem>* "

<longstring> ::= ''' <longstringitem>* ''' | """ <longstringitem>* """

<shortstringitem> ::= <shortstringchar> | <stringescapeseq>

<longstringitem> ::= <longstringchar> | <stringescapeseq>

<shortstringchar> ::= <any_source_character_except_backslash_or_newline_or_quote>

<longstringchar> ::= <any_source_character_except_backslash>

<stringescapeseq> ::= \ <any_source_character>

<bytesliteral> ::= <bytesprefix> ( <shortbytes> | <longbytes> )

<bytesprefix> ::= b | B | br | Br | bR | BR | rb | rB | Rb | RB

<shortbytes> ::= ' <shortbytesitem>* ' | " <shortbytesitem>* "

<longbytes> ::= ''' <longbytesitem>* ''' | """ <longbytesitem>* """

<shortbytesitem> ::= <shortbyteschar> | <bytesescapeseq>

<longbytesitem> ::= <longbyteschar> | <bytesescapeseq>

<shortbyteschar> ::= <any_ascii_character_except_backslash_or_newline_or_quote>

<longbyteschar> ::= <any_ascii_character_except_backslash>

<bytesescapeseq> ::= \ <any_ascii_character>

<integer> ::= <decinteger> | <bininteger> | <octinteger> | <hexinteger>

<decinteger> ::= <nonzerodigit> ( _ ? <digit> )* | 0+ ( _ ? 0 )*

<bininteger> ::= 0 ( b | B ) ( _ ? <bindigit> )+

<octinteger> ::= 0 ( o | O ) ( _ ? <octdigit> )+

<hexinteger> ::= 0 ( x | X ) ( _ ? <hexdigit> )+

<nonzerodigit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<digit> ::= 0 | <nonzerodigit>

<bindigit> ::= 0 | 1

<octdigit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7

<hexdigit> ::= <digit> | a | b | c | d | e | f | A | B | C | D | E | F

<floatnumber> ::= <pointfloat> | <exponentfloat>

<pointfloat> ::= <digitpart>? <fraction> | <digitpart> .

<exponentfloat> ::= ( <digitpart> | <pointfloat> ) <exponent>

<digitpart> ::= <digit> ( _ ? <digit> )*

<fraction> ::= . <digitpart>

<exponent> ::= ( e | E ) ( + | - )? <digitpart>

<imagnumber> ::= ( <floatnumber> | <digitpart> ) ( j | J )

<enclosure> ::= <parenth_form> | <list_display> | <dict_display> | <set_display> | <generator_expression>

<parenth_form> ::= ( <starred_expression>? )

<starred_expression> ::= <expression> | <starred_item>

<starred_item> ::= * <or_expr>

<list_display> ::= [ <starred_list>? ]

<starred_list> ::= <starred_item> ( , <starred_item> )* ,?

<set_display> ::= { <starred_list> }

<dict_display> ::= { <key_datum_list>? } | { <dict_comprehension> }

<key_datum_list> ::= <key_datum> ( , <key_datum> )* ,?

<key_datum> ::= <expression> : <expression> | ** <or_expr>

<dict_comprehension> ::= <key_datum> <comp_for>

<generator_expression> ::= ( <expression> <comp_for> )

<comprehension> ::= <expression> <comp_for>

<comp_for> ::= <async_comp_for> | <sync_comp_for>

<async_comp_for> ::= async for <target_list> in <or_expr> <comp_iter>?

<sync_comp_for> ::= for <target_list> in <or_expr> <comp_iter>?

<comp_iter> ::= <comp_for> | <comp_if>

<comp_if> ::= if <expression_nocond> <comp_iter>?

<expression_nocond> ::= <or_expr>

<target_list> ::= <target> ( , <target> )* ,?

<target> ::= <identifier> | ( <target_list> ) | [ <target_list> ] | <attributeref> | <subscription> | <slicing>

<attributeref> ::= <primary> . <identifier>

<subscription> ::= <primary> [ <expression_list> ]

<slicing> ::= <primary> [ <slice_list> ]

<slice_list> ::= <slice_item> ( , <slice_item> )* ,?

<slice_item> ::= <expression> | <proper_slice>

<proper_slice> ::= <lower_bound>? : <upper_bound>? <stride>?

<lower_bound> ::= <expression>

<upper_bound> ::= <expression>

<stride> ::= : <expression>

<call> ::= <primary> ( <argument_list>? )

<argument_list> ::= <positional_arguments> ( , <starred_and_keywords> )? ( , <keywords_arguments> )? | <starred_and_keywords> ( , <keywords_arguments> )? | <keywords_arguments>

<positional_arguments> ::= <positional_item> ( , <positional_item> )*

<starred_and_keywords> ::= ( * <expression> | <keyword_item> ) ( , * <expression> | , <keyword_item> )*

<keywords_arguments> ::= ( <keyword_item> | ** <expression> ) ( , <keyword_item> | , ** <expression> )*

<positional_item> ::= <assignment_expression> | <expression>

<keyword_item> ::= <identifier> = <expression>

<expression_list> ::= <expression> ( , <expression> )* ,?

<parameter_list> ::= <defparameter> ( , <defparameter> )* ,?

<defparameter> ::= <parameter> | <parameter> = <expression>

<parameter> ::= <identifier> <annotation>?

<annotation> ::= : <expression>

<funcdef> ::= def <identifier> <type_params>? ( <parameter_list>? ) <funcdef_raw>

<funcdef_raw> ::= <annotation>? : <block>

<type_alias> ::= type <identifier> <type_params>? = <expression>

<type_params> ::= [ <type_param> ( , <type_param> )* ,? ]

<type_param> ::= <typevar> | <typevartuple> | <paramspec>

<typevar> ::= <identifier> <type_bound>?

<type_bound> ::= : <expression>

<typevartuple> ::= * <identifier> <type_bound>?

<paramspec> ::= ** <identifier> <type_bound>?

<classdef> ::= class <identifier> <type_params>? <arguments>? : <block>

<arguments> ::= ( <argument_list>? )

<decorators> ::= ( @ <named_expression> NEWLINE )+

<class_def_raw> ::= class <identifier> <type_params>? <arguments>? : <block>

<function_def_raw> ::= def <identifier> <type_params>? ( <parameter_list>? ) <funcdef_raw>

<async_funcdef> ::= async <function_def_raw>

<if_stmt> ::= if <named_expression> : <block> <elif_stmt>*

<elif_stmt> ::= elif <named_expression> : <block>

<else_block> ::= else : <block>

<while_stmt> ::= while <named_expression> : <block> <else_block>?

<for_stmt> ::= for <star_targets> in <star_expressions> : <block> <else_block>?

<async_for_stmt> ::= async <for_stmt>

<with_stmt> ::= with ( <with_item> ( , <with_item> )* )? : <block>

<async_with_stmt> ::= async <with_stmt>

<with_item> ::= <expression> ( as <star_target> )?

<try_stmt> ::= try : <block> <finally_block> | try : <block> <except_block>+ <else_block>? <finally_block>? | try : <block> <except_star_block>+ <else_block>? <finally_block>?

<except_block> ::= except <expression>? ( as <identifier> )? : <block>

<except_star_block> ::= except* <expression> ( as <identifier> )? : <block>

<finally_block> ::= finally : <block>

<match_stmt> ::= match <subject_expr> : NEWLINE INDENT <case_block>+ DEDENT

<subject_expr> ::= <star_named_expression> ( , <star_named_expressions> )?

<case_block> ::= case <patterns> <guard>? : <block>

<guard> ::= if <named_expression>

<patterns> ::= <open_sequence_pattern> | <pattern>

<pattern> ::= <as_pattern> | <or_pattern>

<as_pattern> ::= <or_pattern> as <pattern_capture_target>

<or_pattern> ::= <closed_pattern> ( | <closed_pattern> )*

<closed_pattern> ::= <literal_pattern> | <capture_pattern> | <wildcard_pattern> | <value_pattern> | <group_pattern> | <sequence_pattern> | <mapping_pattern> | <class_pattern>

<literal_pattern> ::= <signed_number> | <complex_number> | <strings> | None | True | False

<capture_pattern> ::= <pattern_capture_target>

<pattern_capture_target> ::= ! ( _ )

<wildcard_pattern> ::= _

<value_pattern> ::= <attr> | <name_or_attr> . NAME | <name_or_attr> . NAME . NAME

<attr> ::= <name_or_attr> . NAME

<name_or_attr> ::= <attr> | NAME

<group_pattern> ::= ( <pattern> )

<sequence_pattern> ::= [ <maybe_sequence_pattern>? ] | ( <open_sequence_pattern>? )

<open_sequence_pattern> ::= <maybe_star_pattern> , <maybe_sequence_pattern>?

<maybe_sequence_pattern> ::= <maybe_star_pattern> ( , <maybe_star_pattern> )* ,?

<maybe_star_pattern> ::= <star_pattern> | <pattern>

<star_pattern> ::= * <pattern_capture_target> | * <wildcard_pattern>

<mapping_pattern> ::= { } | { <double_star_pattern> ,? } | { <items_pattern> , <double_star_pattern> ,? } | { <items_pattern> ,? }

<items_pattern> ::= <key_value_pattern> ( , <key_value_pattern> )*

<key_value_pattern> ::= ( <literal_expr> | <attr> ) : <pattern>

<double_star_pattern> ::= ** <pattern_capture_target>

<class_pattern> ::= <name_or_attr> ( ) | <name_or_attr> ( <positional_patterns> ,? ) | <name_or_attr> ( <keyword_patterns> ,? ) | <name_or_attr> ( <positional_patterns> , <keyword_patterns> ,? )

<positional_patterns> ::= <pattern> ( , <pattern> )*

<keyword_patterns> ::= <keyword_pattern> ( , <keyword_pattern> )*

<keyword_pattern> ::= NAME = <pattern>

<star_targets> ::= <star_target> ( , <star_target> )* ,?

<star_target> ::= * ( ! _ ) <star_target> | <target_with_star_atom>

<target_with_star_atom> ::= <t_primary> . NAME | <t_primary> [ <slices> ] | <star_atom>

<star_atom> ::= NAME | ( <target_with_star_atom> ) | ( <star_targets_list_seq>? ) | [ <star_targets_list_seq>? ]

<star_targets_list_seq> ::= <star_target> ( , <star_target> )* ,?

<star_targets_tuple_seq> ::= <star_target> ( , <star_target> )+ ,? | <star_target> ,

<star_expressions> ::= <star_expression> ( , <star_expression> )* ,?

<star_expression> ::= * <bitwise_or> | <expression>

<star_named_expressions> ::= <star_named_expression> ( , <star_named_expression> )* ,?

<star_named_expression> ::= * <bitwise_or> | <named_expression>

<assignment_expression> ::= NAME := ~ <expression>

<named_expression> ::= <assignment_expression> | <expression>

<annotated_rhs> ::= <yield_expr> | <star_expressions>

<expressions> ::= <expression> ( , <expression> )* ,?

<expression> ::= <disjunction> ( if <disjunction> else <expression> )? | <lambdef>

<yield_expr> ::= yield from <expression> | yield <star_expressions>?

<lambdef> ::= lambda <lambda_params>? : <expression>

<lambda_params> ::= <lambda_parameters>

<lambda_parameters> ::= <lambda_slash_no_default> <lambda_param_no_default>* <lambda_param_with_default>* <lambda_star_etc>? | <lambda_slash_with_default> <lambda_param_with_default>* <lambda_star_etc>? | <lambda_param_no_default>+ <lambda_param_with_default>* <lambda_star_etc>? | <lambda_param_with_default>+ <lambda_star_etc>? | <lambda_star_etc>

<lambda_slash_no_default> ::= <lambda_param_no_default>+ / ,

<lambda_slash_with_default> ::= <lambda_param_no_default>* <lambda_param_with_default>+ / ,

<lambda_star_etc> ::= * <lambda_param_no_default> <lambda_param_maybe_default>* <lambda_kwds>? | * , <lambda_param_maybe_default>+ <lambda_kwds>? | <lambda_kwds>

<lambda_kwds> ::= ** <lambda_param_no_default>

<lambda_param_no_default> ::= <lambda_param> ,

<lambda_param_with_default> ::= <lambda_param> = <expression> ,

<lambda_param_maybe_default> ::= <lambda_param> ( = <expression> )? ,

<lambda_param> ::= NAME

<fstring_middle> ::= <fstring_replacement_field> | FSTRING_MIDDLE

<fstring_replacement_field> ::= { <annotated_rhs> <fstring_conversion>? <fstring_full_format_spec>? }

<fstring_conversion> ::= ! NAME

<fstring_full_format_spec> ::= : <fstring_format_spec>*

<fstring_format_spec> ::= FSTRING_MIDDLE | <fstring_replacement_field>

<string> ::= STRING

<strings> ::= STRING+

<list> ::= [ <star_named_expressions>? ]

<tuple> ::= ( <star_named_expression> , <star_named_expressions>? ) | ( <star_named_expression> , ) | ( )

<set> ::= { <star_named_expressions> }

<dict> ::= { <double_starred_kvpairs>? } | { <kvpair> ( , <double_starred_kvpairs> )? }

<double_starred_kvpairs> ::= <kvpair> ( , <kvpair> )* ,?

<kvpair> ::= <expression> : <expression> | ** <bitwise_or>

<for_if_clauses> ::= <for_if_clause>+

<for_if_clause> ::= <async>? for <star_targets> in ~ <disjunction> ( if <disjunction> )*

<listcomp> ::= [ <named_expression> <for_if_clauses> ]

<setcomp> ::= { <named_expression> <for_if_clauses> }

<genexp> ::= ( <assignment_expression> | <expression> ! := ) <for_if_clauses>

<dictcomp> ::= { <kvpair> <for_if_clauses> }

<arguments> ::= <args> ,? &)

<args> ::= <starred_expression> ( , <args> )? | <kwarg_or_starred> ( , <kwarg_or_starred> )* ( , <kwarg_or_double_starred> ( , <kwarg_or_double_starred> )* )?

<kwarg_or_starred> ::= NAME = <expression> | <starred_expression>

<kwarg_or_double_starred> ::= NAME = <expression> | ** <expression>

<star_targets> ::= <star_target> ( , <star_target> )* ,?

<star_target> ::= * ( ! _ ) <star_target> | <target_with_star_atom>

<target_with_star_atom> ::= <t_primary> . NAME | <t_primary> [ <slices> ] | <star_atom>

<star_atom> ::= NAME | ( <target_with_star_atom> ) | ( <star_targets_list_seq>? ) | [ <star_targets_list_seq>? ]

<single_target> ::= <single_subscript_attribute_target> | NAME | ( <single_target> )

<single_subscript_attribute_target> ::= <t_primary> . NAME | <t_primary> [ <slices> ]

<t_primary> ::= <t_primary> . NAME | <t_primary> [ <slices> ] | <t_primary> <genexp> | <t_primary> ( <arguments>? ) | <atom>

<t_lookahead> ::= ( | [ | .

<del_targets> ::= <del_target> ( , <del_target> )* ,?

<del_target> ::= <t_primary> . NAME | <t_primary> [ <slices> ] | <del_t_atom>

<del_t_atom> ::= NAME | ( <del_target> ) | ( <del_targets>? ) | [ <del_targets>? ]

<type_expressions> ::= <expression> ( , <expression> )* ,?

<func_type_comment> ::= NEWLINE TYPE_COMMENT &( NEWLINE INDENT ) | TYPE_COMMENT

<soft_kw_type> ::= 'type'

<soft_kw_match> ::= 'match'

<soft_kw_case> ::= 'case'

<soft_kw__not__wildcard> ::= ! '_'

