/*
 * C# 10 Grammar Specification (.NET 6)
 * 
 * This grammar is designed for parsing the C# 10 programming language and is suitable for a grammar marketplace.
 * It covers the full language specification, including modern features like record structs, global using directives,
 * file-scoped namespaces, nullable reference types, and enhanced pattern matching. This grammar is based on the 
 * official C# 10 specification and .NET 6 features.
 */

TokenSplitter: Space
Keywords: abstract, as, base, bool, break, byte, case, catch, char, checked, class, const, continue, decimal, default, delegate, do, double, else, enum, event, explicit, extern, false, finally, fixed, float, for, foreach, goto, if, implicit, in, int, interface, internal, is, lock, long, namespace, new, null, object, operator, out, override, params, private, protected, public, readonly, ref, return, sbyte, sealed, short, sizeof, stackalloc, static, string, struct, switch, this, throw, true, try, typeof, uint, ulong, unchecked, unsafe, ushort, using, virtual, void, volatile, while, add, alias, ascending, async, await, by, descending, dynamic, equals, from, get, global, group, into, join, let, nameof, notnull, on, orderby, partial, remove, select, set, unmanaged, value, var, when, where, with, yield, and, or, not, record, init, file, scoped, required

<compilation_unit> ::= <extern_alias_directives>? <using_directives>? <global_attributes>? <namespace_member_declarations>?

<extern_alias_directives> ::= <extern_alias_directive>+

<extern_alias_directive> ::= extern alias <identifier> ;

<using_directives> ::= <using_directive>+

<using_directive> ::= <using_alias_directive> | <using_namespace_directive> | <using_static_directive> | <global_using_directive>

<using_alias_directive> ::= using <identifier> = <namespace_or_type_name> ;

<using_namespace_directive> ::= using <namespace_name> ;

<using_static_directive> ::= using static <type_name> ;

<global_using_directive> ::= global using <namespace_name> ; | global using static <type_name> ; | global using <identifier> = <namespace_or_type_name> ;

<global_attributes> ::= <global_attribute_section>+

<global_attribute_section> ::= [ <global_attribute_target_specifier> <attribute_list> ]

<global_attribute_target_specifier> ::= <global_attribute_target> :

<global_attribute_target> ::= assembly | module

<attribute_list> ::= <attribute> | <attribute_list> , <attribute>

<attribute> ::= <attribute_name> <attribute_arguments>?

<attribute_name> ::= <type_name>

<attribute_arguments> ::= ( <positional_argument_list>? ) | ( <positional_argument_list> , <named_argument_list> ) | ( <named_argument_list> )

<positional_argument_list> ::= <positional_argument> | <positional_argument_list> , <positional_argument>

<positional_argument> ::= <attribute_argument_expression>

<named_argument_list> ::= <named_argument> | <named_argument_list> , <named_argument>

<named_argument> ::= <identifier> = <attribute_argument_expression>

<attribute_argument_expression> ::= <expression>

<namespace_member_declarations> ::= <namespace_member_declaration>+

<namespace_member_declaration> ::= <namespace_declaration> | <type_declaration>

<namespace_declaration> ::= <namespace_header> <namespace_body> <semicolon>? | <file_scoped_namespace_declaration>

<namespace_header> ::= namespace <namespace_name>

<namespace_body> ::= { <extern_alias_directives>? <using_directives>? <namespace_member_declarations>? }

<file_scoped_namespace_declaration> ::= namespace <namespace_name> ;

<namespace_name> ::= <namespace_or_type_name>

<type_declaration> ::= <class_declaration> | <struct_declaration> | <interface_declaration> | <enum_declaration> | <delegate_declaration> | <record_declaration>

<class_declaration> ::= <attributes>? <class_modifiers>? partial? class <identifier> <type_parameter_list>? <class_base>? <type_parameter_constraints_clauses>? <class_body> <semicolon>?

<class_modifiers> ::= <class_modifier>+

<class_modifier> ::= new | public | protected | internal | private | abstract | sealed | static | unsafe | partial

<type_parameter_list> ::= < <type_parameters> >

<type_parameters> ::= <attributes>? <type_parameter> | <type_parameters> , <attributes>? <type_parameter>

<type_parameter> ::= <identifier>

<class_base> ::= : <class_type> | : <interface_type_list> | : <class_type> , <interface_type_list>

<interface_type_list> ::= <interface_type> | <interface_type_list> , <interface_type>

<type_parameter_constraints_clauses> ::= <type_parameter_constraints_clause>+

<type_parameter_constraints_clause> ::= where <type_parameter> : <type_parameter_constraints>

<type_parameter_constraints> ::= <primary_constraint> | <secondary_constraints> | <constructor_constraint> | <primary_constraint> , <secondary_constraints> | <primary_constraint> , <constructor_constraint> | <secondary_constraints> , <constructor_constraint> | <primary_constraint> , <secondary_constraints> , <constructor_constraint>

<primary_constraint> ::= <class_type> | class | class? | struct | notnull | unmanaged

<secondary_constraints> ::= <interface_type> | <type_parameter> | <secondary_constraints> , <interface_type> | <secondary_constraints> , <type_parameter>

<constructor_constraint> ::= new ( )

<class_body> ::= { <class_member_declarations>? }

<class_member_declarations> ::= <class_member_declaration>+

<class_member_declaration> ::= <constant_declaration> | <field_declaration> | <method_declaration> | <property_declaration> | <event_declaration> | <indexer_declaration> | <operator_declaration> | <constructor_declaration> | <destructor_declaration> | <static_constructor_declaration> | <type_declaration>

<constant_declaration> ::= <attributes>? <constant_modifiers>? const <type> <constant_declarators> ;

<constant_modifiers> ::= <constant_modifier>+

<constant_modifier> ::= new | public | protected | internal | private

<constant_declarators> ::= <constant_declarator> | <constant_declarators> , <constant_declarator>

<constant_declarator> ::= <identifier> = <constant_expression>

<field_declaration> ::= <attributes>? <field_modifiers>? <type> <variable_declarators> ;

<field_modifiers> ::= <field_modifier>+

<field_modifier> ::= new | public | protected | internal | private | static | readonly | volatile | unsafe

<variable_declarators> ::= <variable_declarator> | <variable_declarators> , <variable_declarator>

<variable_declarator> ::= <identifier> | <identifier> = <variable_initializer>

<variable_initializer> ::= <expression> | <array_initializer>

<method_declaration> ::= <method_header> <method_body>

<method_header> ::= <attributes>? <method_modifiers>? <partial_modifier>? <return_type> <member_name> <type_parameter_list>? ( <formal_parameter_list>? ) <type_parameter_constraints_clauses>?

<method_modifiers> ::= <method_modifier>+

<method_modifier> ::= new | public | protected | internal | private | static | virtual | sealed | override | abstract | extern | unsafe | async

<partial_modifier> ::= partial

<return_type> ::= <type> | void

<member_name> ::= <identifier> | <interface_type> . <identifier>

<formal_parameter_list> ::= <fixed_parameters> | <fixed_parameters> , <parameter_array> | <parameter_array>

<fixed_parameters> ::= <fixed_parameter> | <fixed_parameters> , <fixed_parameter>

<fixed_parameter> ::= <attributes>? <parameter_modifier>? <type> <identifier> <default_argument>?

<parameter_modifier> ::= ref | out | in | this | scoped

<default_argument> ::= = <expression>

<parameter_array> ::= <attributes>? params <array_type> <identifier>

<method_body> ::= <block> | ; | => <expression> ;

<property_declaration> ::= <attributes>? <property_modifiers>? <type> <member_name> { <accessor_declarations> } | <attributes>? <property_modifiers>? <type> <member_name> => <expression> ;

<property_modifiers> ::= <property_modifier>+

<property_modifier> ::= new | public | protected | internal | private | static | virtual | sealed | override | abstract | extern | unsafe

<accessor_declarations> ::= <get_accessor_declaration> <set_accessor_declaration>? | <set_accessor_declaration> <get_accessor_declaration>? | <get_accessor_declaration> <init_accessor_declaration>? | <init_accessor_declaration> <get_accessor_declaration>?

<get_accessor_declaration> ::= <attributes>? <accessor_modifier>? get <accessor_body>

<set_accessor_declaration> ::= <attributes>? <accessor_modifier>? set <accessor_body>

<init_accessor_declaration> ::= <attributes>? <accessor_modifier>? init <accessor_body>

<accessor_modifier> ::= protected | internal | private | protected internal | private protected

<accessor_body> ::= <block> | ; | => <expression> ;

<event_declaration> ::= <attributes>? <event_modifiers>? event <type> <variable_declarators> ; | <attributes>? <event_modifiers>? event <type> <member_name> { <event_accessor_declarations> }

<event_modifiers> ::= <event_modifier>+

<event_modifier> ::= new | public | protected | internal | private | static | virtual | sealed | override | abstract | extern | unsafe

<event_accessor_declarations> ::= <add_accessor_declaration> <remove_accessor_declaration> | <remove_accessor_declaration> <add_accessor_declaration>

<add_accessor_declaration> ::= <attributes>? add <block>

<remove_accessor_declaration> ::= <attributes>? remove <block>

<indexer_declaration> ::= <attributes>? <indexer_modifiers>? <type> this [ <formal_parameter_list> ] { <accessor_declarations> } | <attributes>? <indexer_modifiers>? <type> <interface_type> . this [ <formal_parameter_list> ] { <accessor_declarations> }

<indexer_modifiers> ::= <indexer_modifier>+

<indexer_modifier> ::= new | public | protected | internal | private | virtual | sealed | override | abstract | extern | unsafe

<operator_declaration> ::= <attributes>? <operator_modifiers> <operator_declarator> <operator_body>

<operator_modifiers> ::= <operator_modifier>+

<operator_modifier> ::= public | static | extern | unsafe

<operator_declarator> ::= <unary_operator_declarator> | <binary_operator_declarator> | <conversion_operator_declarator>

<unary_operator_declarator> ::= <type> operator <overloadable_unary_operator> ( <type> <identifier> )

<overloadable_unary_operator> ::= + | - | ! | ~ | ++ | -- | true | false

<binary_operator_declarator> ::= <type> operator <overloadable_binary_operator> ( <type> <identifier> , <type> <identifier> )

<overloadable_binary_operator> ::= + | - | * | / | % | & | | | ^ | << | >> | == | != | > | < | >= | <=

<conversion_operator_declarator> ::= implicit operator <type> ( <type> <identifier> ) | explicit operator <type> ( <type> <identifier> )

<operator_body> ::= <block> | ; | => <expression> ;

<constructor_declaration> ::= <attributes>? <constructor_modifiers>? <constructor_declarator> <constructor_body>

<constructor_modifiers> ::= <constructor_modifier>+

<constructor_modifier> ::= public | protected | internal | private | extern | unsafe

<constructor_declarator> ::= <identifier> ( <formal_parameter_list>? ) <constructor_initializer>?

<constructor_initializer> ::= : base ( <argument_list>? ) | : this ( <argument_list>? )

<constructor_body> ::= <block> | ; | => <expression> ;

<static_constructor_declaration> ::= <attributes>? <static_constructor_modifiers> <identifier> ( ) <static_constructor_body>

<static_constructor_modifiers> ::= extern? static | static extern?

<static_constructor_body> ::= <block> | ;

<destructor_declaration> ::= <attributes>? extern? ~ <identifier> ( ) <destructor_body>

<destructor_body> ::= <block> | ; | => <expression> ;

<struct_declaration> ::= <attributes>? <struct_modifiers>? partial? struct <identifier> <type_parameter_list>? <struct_interfaces>? <type_parameter_constraints_clauses>? <struct_body> <semicolon>? | <attributes>? <struct_modifiers>? partial? record struct <identifier> <type_parameter_list>? <record_parameters>? <struct_interfaces>? <type_parameter_constraints_clauses>? <record_struct_body> <semicolon>?

<struct_modifiers> ::= <struct_modifier>+

<struct_modifier> ::= new | public | protected | internal | private | unsafe | readonly | ref | partial

<struct_interfaces> ::= : <interface_type_list>

<struct_body> ::= { <struct_member_declarations>? }

<struct_member_declarations> ::= <struct_member_declaration>+

<struct_member_declaration> ::= <constant_declaration> | <field_declaration> | <method_declaration> | <property_declaration> | <event_declaration> | <indexer_declaration> | <operator_declaration> | <constructor_declaration> | <static_constructor_declaration> | <type_declaration>

<record_declaration> ::= <attributes>? <record_modifiers>? record <identifier> <type_parameter_list>? <record_parameters>? <record_base>? <type_parameter_constraints_clauses>? <record_body> <semicolon>?

<record_modifiers> ::= <record_modifier>+

<record_modifier> ::= new | public | protected | internal | private | abstract | sealed | static | unsafe | partial

<record_parameters> ::= ( <record_parameter_list>? )

<record_parameter_list> ::= <record_parameter> | <record_parameter_list> , <record_parameter>

<record_parameter> ::= <attributes>? <type> <identifier> <default_argument>?

<record_base> ::= : <class_type> | : <interface_type_list> | : <class_type> , <interface_type_list>

<record_body> ::= { <record_member_declarations>? } | ;

<record_member_declarations> ::= <record_member_declaration>+

<record_member_declaration> ::= <class_member_declaration>

<record_struct_body> ::= { <record_struct_member_declarations>? } | ;

<record_struct_member_declarations> ::= <record_struct_member_declaration>+

<record_struct_member_declaration> ::= <struct_member_declaration>

<interface_declaration> ::= <attributes>? <interface_modifiers>? partial? interface <identifier> <variant_type_parameter_list>? <interface_base>? <type_parameter_constraints_clauses>? <interface_body> <semicolon>?

<interface_modifiers> ::= <interface_modifier>+

<interface_modifier> ::= new | public | protected | internal | private | unsafe | partial

<variant_type_parameter_list> ::= < <variant_type_parameters> >

<variant_type_parameters> ::= <attributes>? <variance_annotation>? <type_parameter> | <variant_type_parameters> , <attributes>? <variance_annotation>? <type_parameter>

<variance_annotation> ::= in | out

<interface_base> ::= : <interface_type_list>

<interface_body> ::= { <interface_member_declarations>? }

<interface_member_declarations> ::= <interface_member_declaration>+

<interface_member_declaration> ::= <interface_method_declaration> | <interface_property_declaration> | <interface_event_declaration> | <interface_indexer_declaration>

<interface_method_declaration> ::= <attributes>? new? <return_type> <identifier> <type_parameter_list>? ( <formal_parameter_list>? ) <type_parameter_constraints_clauses>? ; | <attributes>? <interface_method_modifiers>? <return_type> <identifier> <type_parameter_list>? ( <formal_parameter_list>? ) <type_parameter_constraints_clauses>? <interface_method_body>

<interface_method_modifiers> ::= <interface_method_modifier>+

<interface_method_modifier> ::= new | static | abstract | virtual | sealed | override | extern | unsafe | async

<interface_method_body> ::= <block> | ; | => <expression> ;

<interface_property_declaration> ::= <attributes>? new? <type> <identifier> { <interface_accessors> } | <attributes>? <interface_property_modifiers>? <type> <identifier> { <interface_accessors> } | <attributes>? <interface_property_modifiers>? <type> <identifier> => <expression> ;

<interface_property_modifiers> ::= <interface_property_modifier>+

<interface_property_modifier> ::= new | static | abstract | virtual | sealed | override | extern | unsafe

<interface_accessors> ::= <attributes>? get ; | <attributes>? set ; | <attributes>? init ; | <attributes>? get ; <attributes>? set ; | <attributes>? get ; <attributes>? init ; | <attributes>? set ; <attributes>? get ; | <attributes>? init ; <attributes>? get ;

<interface_event_declaration> ::= <attributes>? new? event <type> <identifier> ;

<interface_indexer_declaration> ::= <attributes>? new? <type> this [ <formal_parameter_list> ] { <interface_accessors> }

<enum_declaration> ::= <attributes>? <enum_modifiers>? enum <identifier> <enum_base>? <enum_body> <semicolon>?

<enum_modifiers> ::= <enum_modifier>+

<enum_modifier> ::= new | public | protected | internal | private

<enum_base> ::= : <integral_type>

<enum_body> ::= { <enum_member_declarations>? } | { <enum_member_declarations> , }

<enum_member_declarations> ::= <enum_member_declaration> | <enum_member_declarations> , <enum_member_declaration>

<enum_member_declaration> ::= <attributes>? <identifier> | <attributes>? <identifier> = <constant_expression>

<delegate_declaration> ::= <attributes>? <delegate_modifiers>? delegate <return_type> <identifier> <variant_type_parameter_list>? ( <formal_parameter_list>? ) <type_parameter_constraints_clauses>? ;

<delegate_modifiers> ::= <delegate_modifier>+

<delegate_modifier> ::= new | public | protected | internal | private | unsafe

<type> ::= <value_type> | <reference_type> | <type_parameter> | <pointer_type>

<value_type> ::= <struct_type> | <enum_type>

<struct_type> ::= <type_name> | <simple_type> | <nullable_value_type>

<simple_type> ::= <numeric_type> | bool

<numeric_type> ::= <integral_type> | <floating_point_type> | decimal

<integral_type> ::= sbyte | byte | short | ushort | int | uint | long | ulong | char

<floating_point_type> ::= float | double

<nullable_value_type> ::= <non_nullable_value_type> ?

<non_nullable_value_type> ::= <struct_type>

<enum_type> ::= <type_name>

<reference_type> ::= <class_type> | <interface_type> | <array_type> | <delegate_type> | <nullable_reference_type>

<class_type> ::= <type_name> | object | dynamic | string

<interface_type> ::= <type_name>

<array_type> ::= <non_array_type> <rank_specifiers>

<non_array_type> ::= <value_type> | <class_type> | <interface_type> | <delegate_type> | <type_parameter>

<rank_specifiers> ::= <rank_specifier>+

<rank_specifier> ::= [ <dim_separators>? ]

<dim_separators> ::= , | <dim_separators> ,

<delegate_type> ::= <type_name>

<nullable_reference_type> ::= <non_nullable_reference_type> ?

<non_nullable_reference_type> ::= <reference_type>

<type_parameter> ::= <identifier>

<pointer_type> ::= <unmanaged_type> * | void *

<unmanaged_type> ::= <type>

<namespace_or_type_name> ::= <identifier> <type_argument_list>? | <namespace_or_type_name> . <identifier> <type_argument_list>?

<type_name> ::= <namespace_or_type_name>

<type_argument_list> ::= < <type_arguments> >

<type_arguments> ::= <type_argument> | <type_arguments> , <type_argument>

<type_argument> ::= <type>

<variable_reference> ::= <expression>

<argument_list> ::= <argument> | <argument_list> , <argument>

<argument> ::= <argument_name>? <argument_value>

<argument_name> ::= <identifier> :

<argument_value> ::= <expression> | ref <variable_reference> | out <variable_reference> | in <variable_reference>

<primary_expression> ::= <primary_no_array_creation_expression> | <array_creation_expression>

<primary_no_array_creation_expression> ::= <literal> | <interpolated_string_expression> | <simple_name> | <parenthesized_expression> | <member_access> | <null_conditional_member_access> | <invocation_expression> | <element_access> | <null_conditional_element_access> | <this_access> | <base_access> | <post_increment_expression> | <post_decrement_expression> | <object_creation_expression> | <delegate_creation_expression> | <anonymous_object_creation_expression> | <typeof_expression> | <sizeof_expression> | <checked_expression> | <unchecked_expression> | <default_value_expression> | <nameof_expression> | <anonymous_method_expression> | <pointer_member_access> | <pointer_element_access> | <stackalloc_expression> | <tuple_expression> | <with_expression> | <switch_expression>

<literal> ::= <boolean_literal> | <integer_literal> | <real_literal> | <character_literal> | <string_literal> | <null_literal>

<boolean_literal> ::= true | false

<integer_literal> ::= <decimal_integer_literal> | <hexadecimal_integer_literal> | <binary_integer_literal>

<decimal_integer_literal> ::= <decimal_digits> <integer_type_suffix>?

<decimal_digits> ::= <decimal_digit> | <decimal_digits> <decimal_digit>

<decimal_digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<integer_type_suffix> ::= U | u | L | l | UL | Ul | uL | ul | LU | Lu | lU | lu

<hexadecimal_integer_literal> ::= 0x <hex_digits> <integer_type_suffix>? | 0X <hex_digits> <integer_type_suffix>?

<hex_digits> ::= <hex_digit> | <hex_digits> <hex_digit>

<hex_digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F | a | b | c | d | e | f

<binary_integer_literal> ::= 0b <binary_digits> <integer_type_suffix>? | 0B <binary_digits> <integer_type_suffix>?

<binary_digits> ::= <binary_digit> | <binary_digits> <binary_digit>

<binary_digit> ::= 0 | 1

<real_literal> ::= <decimal_digits> . <decimal_digits> <exponent_part>? <real_type_suffix>? | . <decimal_digits> <exponent_part>? <real_type_suffix>? | <decimal_digits> <exponent_part> <real_type_suffix>? | <decimal_digits> <real_type_suffix>

<exponent_part> ::= e <sign>? <decimal_digits> | E <sign>? <decimal_digits>

<sign> ::= + | -

<real_type_suffix> ::= F | f | D | d | M | m

<character_literal> ::= ' <character> '

<character> ::= <single_character> | <simple_escape_sequence> | <hexadecimal_escape_sequence> | <unicode_escape_sequence>

<single_character> ::= <any_character_except_quote_backslash_and_newline>

<simple_escape_sequence> ::= \' | \" | \\ | \0 | \a | \b | \f | \n | \r | \t | \v

<hexadecimal_escape_sequence> ::= \x <hex_digit> | \x <hex_digit> <hex_digit> | \x <hex_digit> <hex_digit> <hex_digit> | \x <hex_digit> <hex_digit> <hex_digit> <hex_digit>

<unicode_escape_sequence> ::= \u <hex_digit> <hex_digit> <hex_digit> <hex_digit> | \U <hex_digit> <hex_digit> <hex_digit> <hex_digit> <hex_digit> <hex_digit> <hex_digit> <hex_digit>

<string_literal> ::= <regular_string_literal> | <verbatim_string_literal>

<regular_string_literal> ::= " <regular_string_literal_characters>? "

<regular_string_literal_characters> ::= <regular_string_literal_character>+

<regular_string_literal_character> ::= <single_regular_string_literal_character> | <simple_escape_sequence> | <hexadecimal_escape_sequence> | <unicode_escape_sequence>

<single_regular_string_literal_character> ::= <any_character_except_quote_backslash_and_newline>

<verbatim_string_literal> ::= @" <verbatim_string_literal_characters>? "

<verbatim_string_literal_characters> ::= <verbatim_string_literal_character>+

<verbatim_string_literal_character> ::= <single_verbatim_string_literal_character> | <quote_escape_sequence>

<single_verbatim_string_literal_character> ::= <any_character_except_quote>

<quote_escape_sequence> ::= ""

<null_literal> ::= null

<interpolated_string_expression> ::= <interpolated_regular_string> | <interpolated_verbatim_string>

<interpolated_regular_string> ::= $ " <interpolated_regular_string_parts>? "

<interpolated_regular_string_parts> ::= <interpolated_regular_string_part>+

<interpolated_regular_string_part> ::= <interpolated_regular_string_text> | <interpolation>

<interpolated_regular_string_text> ::= <interpolated_regular_string_text_character>+

<interpolated_regular_string_text_character> ::= <any_character_except_quote_backslash_brace_and_newline> | <simple_escape_sequence> | <hexadecimal_escape_sequence> | <unicode_escape_sequence> | <open_brace_escape_sequence> | <close_brace_escape_sequence>

<open_brace_escape_sequence> ::= {{

<close_brace_escape_sequence> ::= }}

<interpolated_verbatim_string> ::= $@ " <interpolated_verbatim_string_parts>? " | @$ " <interpolated_verbatim_string_parts>? "

<interpolated_verbatim_string_parts> ::= <interpolated_verbatim_string_part>+

<interpolated_verbatim_string_part> ::= <interpolated_verbatim_string_text> | <interpolation>

<interpolated_verbatim_string_text> ::= <interpolated_verbatim_string_text_character>+

<interpolated_verbatim_string_text_character> ::= <any_character_except_quote_and_brace> | <quote_escape_sequence> | <open_brace_escape_sequence> | <close_brace_escape_sequence>

<interpolation> ::= { <expression> } | { <expression> , <interpolation_alignment> } | { <expression> : <interpolation_format> } | { <expression> , <interpolation_alignment> : <interpolation_format> }

<interpolation_alignment> ::= <constant_expression>

<interpolation_format> ::= <interpolation_format_character>+

<interpolation_format_character> ::= <any_character_except_quote_backslash_brace_and_newline>

<simple_name> ::= <identifier> <type_argument_list>?

<parenthesized_expression> ::= ( <expression> )

<member_access> ::= <primary_expression> . <identifier> <type_argument_list>? | <predefined_type> . <identifier> <type_argument_list>? | <qualified_alias_member> . <identifier> <type_argument_list>?

<predefined_type> ::= bool | byte | char | decimal | double | float | int | long | object | sbyte | short | string | uint | ulong | ushort

<qualified_alias_member> ::= <identifier> :: <identifier> <type_argument_list>?

<null_conditional_member_access> ::= <primary_expression> ?. <identifier> <type_argument_list>?

<invocation_expression> ::= <primary_expression> ( <argument_list>? )

<element_access> ::= <primary_no_array_creation_expression> [ <expression_list> ]

<expression_list> ::= <expression> | <expression_list> , <expression>

<null_conditional_element_access> ::= <primary_no_array_creation_expression> ?[ <expression_list> ]

<this_access> ::= this

<base_access> ::= base . <identifier> <type_argument_list>? | base [ <expression_list> ]

<post_increment_expression> ::= <primary_expression> ++

<post_decrement_expression> ::= <primary_expression> --

<object_creation_expression> ::= new <type> ( <argument_list>? ) <object_or_collection_initializer>? | new <type> <object_or_collection_initializer> | new <object_or_collection_initializer>

<object_or_collection_initializer> ::= <object_initializer> | <collection_initializer>

<object_initializer> ::= { <member_initializer_list>? } | { <member_initializer_list> , }

<member_initializer_list> ::= <member_initializer> | <member_initializer_list> , <member_initializer>

<member_initializer> ::= <initializer_target> = <initializer_value>

<initializer_target> ::= <identifier> | [ <expression_list> ]

<initializer_value> ::= <expression> | <object_or_collection_initializer>

<collection_initializer> ::= { <element_initializer_list> } | { <element_initializer_list> , }

<element_initializer_list> ::= <element_initializer> | <element_initializer_list> , <element_initializer>

<element_initializer> ::= <non_assignment_expression> | { <expression_list> }

<array_creation_expression> ::= new <non_array_type> [ <expression_list> ] <rank_specifiers>? <array_initializer>? | new <array_type> <array_initializer> | new <rank_specifier> <array_initializer>

<delegate_creation_expression> ::= new <delegate_type> ( <expression> )

<anonymous_object_creation_expression> ::= new <anonymous_object_initializer>

<anonymous_object_initializer> ::= { <member_declarator_list>? } | { <member_declarator_list> , }

<member_declarator_list> ::= <member_declarator> | <member_declarator_list> , <member_declarator>

<member_declarator> ::= <simple_name> | <member_access> | <identifier> = <expression>

<typeof_expression> ::= typeof ( <type> ) | typeof ( <unbound_type_name> ) | typeof ( void )

<unbound_type_name> ::= <identifier> <generic_dimension_specifier>? | <identifier> :: <identifier> <generic_dimension_specifier>? | <unbound_type_name> . <identifier> <generic_dimension_specifier>?

<generic_dimension_specifier> ::= < <commas>? >

<commas> ::= , | <commas> ,

<sizeof_expression> ::= sizeof ( <unmanaged_type> )

<checked_expression> ::= checked ( <expression> )

<unchecked_expression> ::= unchecked ( <expression> )

<default_value_expression> ::= default ( <type> ) | default

<nameof_expression> ::= nameof ( <named_entity> )

<named_entity> ::= <simple_name> | <member_access> | <qualified_alias_member>

<anonymous_method_expression> ::= delegate <explicit_anonymous_function_signature>? <block>

<explicit_anonymous_function_signature> ::= ( <explicit_anonymous_function_parameter_list>? )

<explicit_anonymous_function_parameter_list> ::= <explicit_anonymous_function_parameter> | <explicit_anonymous_function_parameter_list> , <explicit_anonymous_function_parameter>

<explicit_anonymous_function_parameter> ::= <anonymous_function_parameter_modifier>? <type> <identifier>

<anonymous_function_parameter_modifier> ::= ref | out | in

<pointer_member_access> ::= <primary_expression> -> <identifier> <type_argument_list>?

<pointer_element_access> ::= <primary_no_array_creation_expression> [ <expression> ]

<stackalloc_expression> ::= stackalloc <unmanaged_type> [ <expression> ] | stackalloc <unmanaged_type>? [ <expression_list> ] | stackalloc <unmanaged_type> [ ]

<tuple_expression> ::= ( <tuple_element> , <tuple_element_list> )

<tuple_element_list> ::= <tuple_element> | <tuple_element_list> , <tuple_element>

<tuple_element> ::= <expression> | <identifier> : <expression>

<with_expression> ::= <primary_expression> with { <member_initializer_list>? } | <primary_expression> with { <member_initializer_list> , }

<switch_expression> ::= <range_expression> switch { <switch_expression_arms>? }

<switch_expression_arms> ::= <switch_expression_arm> | <switch_expression_arms> , <switch_expression_arm>

<switch_expression_arm> ::= <pattern> <case_guard>? => <expression>

<case_guard> ::= when <expression>

<range_expression> ::= <unary_expression> | <unary_expression> .. <unary_expression> | <unary_expression> .. | .. <unary_expression> | ..

<unary_expression> ::= <primary_expression> | + <unary_expression> | - <unary_expression> | ! <unary_expression> | ~ <unary_expression> | <pre_increment_expression> | <pre_decrement_expression> | <cast_expression> | <await_expression> | <pointer_indirection_expression> | <addressof_expression>

<pre_increment_expression> ::= ++ <unary_expression>

<pre_decrement_expression> ::= -- <unary_expression>

<cast_expression> ::= ( <type> ) <unary_expression>

<await_expression> ::= await <unary_expression>

<pointer_indirection_expression> ::= * <unary_expression>

<addressof_expression> ::= & <unary_expression>

<multiplicative_expression> ::= <unary_expression> | <multiplicative_expression> * <unary_expression> | <multiplicative_expression> / <unary_expression> | <multiplicative_expression> % <unary_expression>

<additive_expression> ::= <multiplicative_expression> | <additive_expression> + <multiplicative_expression> | <additive_expression> - <multiplicative_expression>

<shift_expression> ::= <additive_expression> | <shift_expression> << <additive_expression> | <shift_expression> >> <additive_expression>

<relational_expression> ::= <shift_expression> | <relational_expression> < <shift_expression> | <relational_expression> > <shift_expression> | <relational_expression> <= <shift_expression> | <relational_expression> >= <shift_expression> | <relational_expression> is <type> | <relational_expression> is <pattern> | <relational_expression> as <reference_type> | <relational_expression> as <nullable_value_type>

<equality_expression> ::= <relational_expression> | <equality_expression> == <relational_expression> | <equality_expression> != <relational_expression>

<and_expression> ::= <equality_expression> | <and_expression> & <equality_expression>

<exclusive_or_expression> ::= <and_expression> | <exclusive_or_expression> ^ <and_expression>

<inclusive_or_expression> ::= <exclusive_or_expression> | <inclusive_or_expression> | <exclusive_or_expression>

<conditional_and_expression> ::= <inclusive_or_expression> | <conditional_and_expression> && <inclusive_or_expression>

<conditional_or_expression> ::= <conditional_and_expression> | <conditional_or_expression> || <conditional_and_expression>

<null_coalescing_expression> ::= <conditional_or_expression> | <null_coalescing_expression> ?? <conditional_or_expression>

<conditional_expression> ::= <null_coalescing_expression> | <null_coalescing_expression> ? <expression> : <expression>

<lambda_expression> ::= <anonymous_function_signature> => <anonymous_function_body>

<anonymous_function_signature> ::= <explicit_anonymous_function_signature> | <implicit_anonymous_function_signature>

<implicit_anonymous_function_signature> ::= <implicit_anonymous_function_parameter> | ( <implicit_anonymous_function_parameter_list>? )

<implicit_anonymous_function_parameter_list> ::= <implicit_anonymous_function_parameter> | <implicit_anonymous_function_parameter_list> , <implicit_anonymous_function_parameter>

<implicit_anonymous_function_parameter> ::= <identifier>

<anonymous_function_body> ::= <expression> | <block>

<query_expression> ::= <from_clause> <query_body>

<from_clause> ::= from <type>? <identifier> in <expression>

<query_body> ::= <query_body_clauses>? <select_or_group_clause> <query_continuation>?

<query_body_clauses> ::= <query_body_clause>+

<query_body_clause> ::= <from_clause> | <let_clause> | <where_clause> | <join_clause> | <orderby_clause>

<let_clause> ::= let <identifier> = <expression>

<where_clause> ::= where <boolean_expression>

<join_clause> ::= join <type>? <identifier> in <expression> on <expression> equals <expression> <into_clause>?

<into_clause> ::= into <identifier>

<orderby_clause> ::= orderby <orderings>

<orderings> ::= <ordering> | <orderings> , <ordering>

<ordering> ::= <expression> <ordering_direction>?

<ordering_direction> ::= ascending | descending

<select_or_group_clause> ::= <select_clause> | <group_clause>

<select_clause> ::= select <expression>

<group_clause> ::= group <expression> by <expression>

<query_continuation> ::= into <identifier> <query_body>

<assignment> ::= <unary_expression> <assignment_operator> <expression>

<assignment_operator> ::= = | += | -= | *= | /= | %= | &= | |= | ^= | <<= | >>=

<expression> ::= <non_assignment_expression> | <assignment>

<non_assignment_expression> ::= <conditional_expression> | <lambda_expression> | <query_expression>

<constant_expression> ::= <expression>

<boolean_expression> ::= <expression>

<statement> ::= <labeled_statement> | <declaration_statement> | <embedded_statement>

<embedded_statement> ::= <block> | <empty_statement> | <expression_statement> | <selection_statement> | <iteration_statement> | <jump_statement> | <try_statement> | <checked_statement> | <unchecked_statement> | <lock_statement> | <using_statement> | <yield_statement> | <unsafe_statement> | <fixed_statement>

<block> ::= { <statement_list>? }

<statement_list> ::= <statement>+

<empty_statement> ::= ;

<labeled_statement> ::= <identifier> : <statement>

<declaration_statement> ::= <local_variable_declaration> ; | <local_constant_declaration> ; | <local_function_declaration>

<local_variable_declaration> ::= <local_variable_type> <local_variable_declarators> | using <local_variable_type> <local_variable_declarators>

<local_variable_type> ::= <type> | var

<local_variable_declarators> ::= <local_variable_declarator> | <local_variable_declarators> , <local_variable_declarator>

<local_variable_declarator> ::= <identifier> | <identifier> = <local_variable_initializer>

<local_variable_initializer> ::= <expression> | <array_initializer>

<local_constant_declaration> ::= const <type> <constant_declarators>

<local_function_declaration> ::= <local_function_header> <local_function_body>

<local_function_header> ::= <local_function_modifiers>? <return_type> <identifier> <type_parameter_list>? ( <formal_parameter_list>? ) <type_parameter_constraints_clauses>?

<local_function_modifiers> ::= <local_function_modifier>+

<local_function_modifier> ::= async | unsafe | static | extern

<local_function_body> ::= <block> | => <expression> ;

<expression_statement> ::= <statement_expression> ;

<statement_expression> ::= <invocation_expression> | <null_conditional_invocation_expression> | <object_creation_expression> | <assignment> | <post_increment_expression> | <post_decrement_expression> | <pre_increment_expression> | <pre_decrement_expression> | <await_expression>

<null_conditional_invocation_expression> ::= <primary_expression> ?. <identifier> <type_argument_list>? ( <argument_list>? ) | <primary_expression> ?[ <expression_list> ]

<selection_statement> ::= <if_statement> | <switch_statement>

<if_statement> ::= if ( <boolean_expression> ) <embedded_statement> | if ( <boolean_expression> ) <embedded_statement> else <embedded_statement>

<switch_statement> ::= switch ( <expression> ) <switch_block>

<switch_block> ::= { <switch_sections>? }

<switch_sections> ::= <switch_section>+

<switch_section> ::= <switch_labels> <statement_list>

<switch_labels> ::= <switch_label>+

<switch_label> ::= case <pattern> <case_guard>? : | case <constant_expression> <case_guard>? : | default :

<pattern> ::= <declaration_pattern> | <constant_pattern> | <var_pattern> | <discard_pattern> | <type_pattern> | <parenthesized_pattern> | <relational_pattern> | <logical_pattern> | <property_pattern> | <positional_pattern> | <list_pattern>

<declaration_pattern> ::= <type> <designation>

<designation> ::= <simple_designation> | <tuple_designation> | <discard_designation>

<simple_designation> ::= <identifier>

<tuple_designation> ::= ( <designations>? )

<designations> ::= <designation> | <designations> , <designation>

<discard_designation> ::= _

<constant_pattern> ::= <constant_expression>

<var_pattern> ::= var <designation>

<discard_pattern> ::= _

<type_pattern> ::= <type>

<parenthesized_pattern> ::= ( <pattern> )

<relational_pattern> ::= < <relational_expression> | <= <relational_expression> | > <relational_expression> | >= <relational_expression>

<logical_pattern> ::= <pattern> and <pattern> | <pattern> or <pattern> | not <pattern>

<property_pattern> ::= <type>? { <property_pattern_clause_list>? }

<property_pattern_clause_list> ::= <property_pattern_clause> | <property_pattern_clause_list> , <property_pattern_clause>

<property_pattern_clause> ::= <identifier> : <pattern> | <nested_identifier> : <pattern>

<nested_identifier> ::= <identifier> . <identifier> | <nested_identifier> . <identifier>

<positional_pattern> ::= <type>? ( <positional_pattern_clause_list>? )

<positional_pattern_clause_list> ::= <positional_pattern_clause> | <positional_pattern_clause_list> , <positional_pattern_clause>

<positional_pattern_clause> ::= <pattern>

<list_pattern> ::= [ <list_pattern_clause_list>? ]

<list_pattern_clause_list> ::= <list_pattern_clause> | <list_pattern_clause_list> , <list_pattern_clause>

<list_pattern_clause> ::= <pattern> | .. <pattern>?

<iteration_statement> ::= <while_statement> | <do_statement> | <for_statement> | <foreach_statement>

<while_statement> ::= while ( <boolean_expression> ) <embedded_statement>

<do_statement> ::= do <embedded_statement> while ( <boolean_expression> ) ;

<for_statement> ::= for ( <for_initializer>? ; <for_condition>? ; <for_iterator>? ) <embedded_statement>

<for_initializer> ::= <local_variable_declaration> | <statement_expression_list>

<for_condition> ::= <boolean_expression>

<for_iterator> ::= <statement_expression_list>

<statement_expression_list> ::= <statement_expression> | <statement_expression_list> , <statement_expression>

<foreach_statement> ::= foreach ( <local_variable_type> <identifier> in <expression> ) <embedded_statement> | await foreach ( <local_variable_type> <identifier> in <expression> ) <embedded_statement>

<jump_statement> ::= <break_statement> | <continue_statement> | <goto_statement> | <return_statement> | <throw_statement>

<break_statement> ::= break ;

<continue_statement> ::= continue ;

<goto_statement> ::= goto <identifier> ; | goto case <constant_expression> ; | goto default ;

<return_statement> ::= return <expression>? ;

<throw_statement> ::= throw <expression>? ;

<try_statement> ::= try <block> <catch_clauses> | try <block> <finally_clause> | try <block> <catch_clauses> <finally_clause>

<catch_clauses> ::= <specific_catch_clauses> <general_catch_clause>? | <general_catch_clause>

<specific_catch_clauses> ::= <specific_catch_clause>+

<specific_catch_clause> ::= catch ( <class_type> <identifier>? ) <exception_filter>? <block>

<general_catch_clause> ::= catch <exception_filter>? <block>

<exception_filter> ::= when ( <boolean_expression> )

<finally_clause> ::= finally <block>

<checked_statement> ::= checked <block>

<unchecked_statement> ::= unchecked <block>

<lock_statement> ::= lock ( <expression> ) <embedded_statement>

<using_statement> ::= using ( <resource_acquisition> ) <embedded_statement> | using <resource_acquisition> <embedded_statement>

<resource_acquisition> ::= <local_variable_declaration> | <expression>

<yield_statement> ::= yield return <expression> ; | yield break ;

<unsafe_statement> ::= unsafe <block>

<fixed_statement> ::= fixed ( <pointer_type> <fixed_pointer_declarators> ) <embedded_statement>

<fixed_pointer_declarators> ::= <fixed_pointer_declarator> | <fixed_pointer_declarators> , <fixed_pointer_declarator>

<fixed_pointer_declarator> ::= <identifier> = <fixed_pointer_initializer>

<fixed_pointer_initializer> ::= & <variable_reference> | <expression>

<array_initializer> ::= { <variable_initializer_list>? } | { <variable_initializer_list> , }

<variable_initializer_list> ::= <variable_initializer> | <variable_initializer_list> , <variable_initializer>

<attributes> ::= <attribute_section>+

<attribute_section> ::= [ <attribute_target_specifier>? <attribute_list> ]

<attribute_target_specifier> ::= <attribute_target> :

<attribute_target> ::= field | event | method | param | property | return | type

<identifier> ::= <available_identifier> | @ <identifier_or_keyword>

<available_identifier> ::= <identifier_or_keyword> but not a <keyword>

<identifier_or_keyword> ::= <identifier_start_character> <identifier_part_characters>?

<identifier_start_character> ::= <letter_character> | _ | <unicode_escape_sequence>

<identifier_part_characters> ::= <identifier_part_character>+

<identifier_part_character> ::= <letter_character> | <decimal_digit_character> | <connecting_character> | <combining_character> | <formatting_character> | <unicode_escape_sequence>

<letter_character> ::= <unicode_character_of_classes_Lu_Ll_Lt_Lm_Lo_or_Nl>

<combining_character> ::= <unicode_character_of_classes_Mn_or_Mc>

<decimal_digit_character> ::= <unicode_character_of_the_class_Nd>

<connecting_character> ::= <unicode_character_of_the_class_Pc>

<formatting_character> ::= <unicode_character_of_the_class_Cf>

<keyword> ::= abstract | as | base | bool | break | byte | case | catch | char | checked | class | const | continue | decimal | default | delegate | do | double | else | enum | event | explicit | extern | false | finally | fixed | float | for | foreach | goto | if | implicit | in | int | interface | internal | is | lock | long | namespace | new | null | object | operator | out | override | params | private | protected | public | readonly | ref | return | sbyte | sealed | short | sizeof | stackalloc | static | string | struct | switch | this | throw | true | try | typeof | uint | ulong | unchecked | unsafe | ushort | using | virtual | void | volatile | while | add | alias | ascending | async | await | by | descending | dynamic | equals | from | get | global | group | into | join | let | nameof | notnull | on | orderby | partial | remove | select | set | unmanaged | value | var | when | where | with | yield | and | or | not | record | init | file | scoped | required

<contextual_keyword> ::= add | alias | ascending | async | await | by | descending | dynamic | equals | from | get | global | group | into | join | let | nameof | notnull | on | orderby | partial | remove | select | set | unmanaged | value | var | when | where | with | yield | and | or | not | record | init | file | scoped | required

