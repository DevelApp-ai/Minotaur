@page "/grammar-editor"
@using Minotaur.Core
@using Minotaur.Editor
@using Minotaur.UI.Blazor.Services
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject GrammarSyntaxHighlightingService SyntaxService
@inject GrammarCodeCompletionService CompletionService

<PageTitle>Grammar Editor</PageTitle>

<div class="grammar-editor">
    <div class="row h-100">
        <!-- Left Panel: Grammar Editor -->
        <div class="col-md-8">
            <div class="card h-100">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0">
                        <i class="bi bi-file-earmark-text"></i> Grammar Editor
                    </h5>
                    <div class="btn-group" role="group">
                        <button class="btn btn-outline-primary btn-sm" @onclick="NewGrammar">
                            <i class="bi bi-file-plus"></i> New
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" @onclick="OpenGrammar">
                            <i class="bi bi-folder-open"></i> Open
                        </button>
                        <button class="btn btn-outline-success btn-sm" @onclick="SaveGrammar" disabled="@(!hasUnsavedChanges)">
                            <i class="bi bi-save"></i> Save
                        </button>
                        <button class="btn btn-outline-info btn-sm" @onclick="OpenMarketplace">
                            <i class="bi bi-shop"></i> Marketplace
                        </button>
                        <button class="btn btn-outline-warning btn-sm" @onclick="AnalyzeShifts" disabled="@isAnalyzingShifts">
                            @if (isAnalyzingShifts)
                            {
                                <i class="bi bi-arrow-repeat rotating"></i> <text>Analyzing...</text>
                            }
                            else
                            {
                                <i class="bi bi-graph-up-arrow"></i> <text>Detect Shifts</text>
                            }
                        </button>
                        <button class="btn btn-primary btn-sm" @onclick="ParseGrammar" disabled="@isParsingGrammar">
                            @if (isParsingGrammar)
                            {
                                <span class="spinner-border spinner-border-sm me-1"></span>
                                <span>Parsing...</span>
                            }
                            else
                            {
                                <i class="bi bi-play-fill"></i>
                                <span>Parse</span>
                            }
                        </button>
                    </div>
                </div>
                <div class="card-body p-0 position-relative">
                    <!-- Grammar Metadata -->
                    <div class="grammar-metadata border-bottom p-2">
                        <div class="row g-2">
                            <div class="col-md-3">
                                <input @bind="grammarName" @oninput="OnGrammarMetadataChanged" 
                                       class="form-control form-control-sm" placeholder="Grammar Name" />
                            </div>
                            <div class="col-md-3">
                                <select @bind="grammarType" class="form-select form-select-sm">
                                    <option value="lexer">Lexer Grammar</option>
                                    <option value="parser">Parser Grammar</option>
                                    <option value="combined">Combined Grammar</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <input @bind="grammarVersion" @oninput="OnGrammarMetadataChanged" 
                                       class="form-control form-control-sm" placeholder="Version" />
                            </div>
                            <div class="col-md-3">
                                <div class="form-check form-check-inline">
                                    <input @bind="enableSyntaxHighlighting" 
                                           class="form-check-input" type="checkbox" id="syntaxHighlighting" />
                                    <label class="form-check-label" for="syntaxHighlighting">
                                        Syntax Highlighting
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Code Editor -->
                    <div class="code-editor-container">
                        <div class="editor-gutter">
                            @for (int i = 1; i <= grammarContent.Split('\n').Length; i++)
                            {
                                <div class="line-number @(grammarErrors.Any(e => e.Line == i) ? "error-line" : "")">
                                    @i
                                    @if (grammarErrors.Any(e => e.Line == i))
                                    {
                                        <i class="bi bi-exclamation-triangle-fill text-danger" 
                                           title="@string.Join(", ", grammarErrors.Where(e => e.Line == i).Select(e => e.Message))"></i>
                                    }
                                </div>
                            }
                        </div>
                        @if (enableSyntaxHighlighting && !string.IsNullOrEmpty(highlightedContent))
                        {
                            <div class="code-editor-highlighted" @onclick="FocusEditor">
                                @((MarkupString)highlightedContent)
                            </div>
                            <textarea @bind="grammarContent" @oninput="OnGrammarContentChanged" @onkeydown="OnKeyDown" @ref="codeEditorElement"
                                      class="code-editor code-editor-overlay" 
                                      placeholder="Enter your grammar definition here..."
                                      style="position: absolute; background: transparent; color: transparent; caret-color: black; z-index: 2;"></textarea>
                        }
                        else
                        {
                            <textarea @bind="grammarContent" @oninput="OnGrammarContentChanged" @onkeydown="OnKeyDown" @ref="codeEditorElement"
                                      class="code-editor"
                                      placeholder="Enter your grammar definition here..."></textarea>
                        }
                        
                        <!-- Code Completion Dropdown -->
                        @if (showCompletionDropdown && completionItems.Any())
                        {
                            <div class="completion-dropdown" style="top: @(completionDropdownTop)px; left: @(completionDropdownLeft)px;">
                                @foreach (var item in completionItems.Take(10))
                                {
                                    <div class="completion-item @(item == selectedCompletionItem ? "selected" : "")" 
                                         @onclick="() => InsertCompletion(item)">
                                        <i class="bi @GetCompletionIcon(item.Kind)"></i>
                                        <span class="completion-label">@item.Label</span>
                                        <span class="completion-detail">@item.Detail</span>
                                    </div>
                                }
                            </div>
                        }
                    </div>

                    <!-- Status Bar -->
                    <div class="editor-status-bar">
                        <div class="status-left">
                            <span class="status-item">
                                <i class="bi bi-cursor-text"></i> 
                                Line @currentLine, Column @currentColumn
                            </span>
                            <span class="status-item">
                                <i class="bi bi-file-text"></i> 
                                @grammarContent.Split('\n').Length lines, @grammarContent.Length chars
                            </span>
                            @if (hasUnsavedChanges)
                            {
                                <span class="status-item text-warning">
                                    <i class="bi bi-circle-fill"></i> Unsaved changes
                                </span>
                            }
                        </div>
                        <div class="status-right">
                            @if (grammarErrors.Any())
                            {
                                <span class="status-item text-danger">
                                    <i class="bi bi-exclamation-triangle"></i> 
                                    @grammarErrors.Count error@(grammarErrors.Count != 1 ? "s" : "")
                                </span>
                            }
                            else if (isGrammarValid)
                            {
                                <span class="status-item text-success">
                                    <i class="bi bi-check-circle"></i> Valid grammar
                                </span>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Grammar Analysis -->
        <div class="col-md-4">
            <div class="card h-100">
                <div class="card-header">
                    <ul class="nav nav-tabs card-header-tabs" role="tablist">
                        <li class="nav-item">
                            <a class="nav-link @(activeTab == "rules" ? "active" : "")" 
                               @onclick='() => SetActiveTab("rules")' href="#">
                                <i class="bi bi-list-ul"></i> Rules
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link @(activeTab == "analysis" ? "active" : "")" 
                               @onclick='() => SetActiveTab("analysis")' href="#">
                                <i class="bi bi-graph-up"></i> Analysis
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link @(activeTab == "errors" ? "active" : "")" 
                               @onclick='() => SetActiveTab("errors")' href="#">
                                <i class="bi bi-exclamation-triangle"></i> Errors
                            </a>
                        </li>
                    </ul>
                </div>
                <div class="card-body">
                    <!-- Rules Tab -->
                    @if (activeTab == "rules")
                    {
                        <div class="grammar-rules">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0">Grammar Rules (@grammarRules.Count)</h6>
                                <button class="btn btn-outline-primary btn-sm" @onclick="AddNewRule">
                                    <i class="bi bi-plus"></i> Add Rule
                                </button>
                            </div>
                            
                            @if (grammarRules.Any())
                            {
                                <div class="rules-list">
                                    @foreach (var rule in grammarRules)
                                    {
                                        <div class="rule-item @(selectedRuleName == rule.Name ? "selected" : "")" 
                                             @onclick="() => SelectRule(rule.Name)">
                                            <div class="rule-header">
                                                <strong>@rule.Name</strong>
                                                <span class="badge bg-secondary">@rule.Type</span>
                                            </div>
                                            <div class="rule-preview">@rule.Definition</div>
                                            <div class="rule-stats">
                                                <small class="text-muted">
                                                    @rule.References references â€¢ @rule.Alternatives alternatives
                                                </small>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                            else
                            {
                                <div class="text-center text-muted">
                                    <i class="bi bi-list-ul fs-1"></i>
                                    <p>No rules defined yet</p>
                                </div>
                            }
                        </div>
                    }

                    <!-- Analysis Tab -->
                    @if (activeTab == "analysis")
                    {
                        <div class="grammar-analysis">
                            @if (grammarAnalysis != null)
                            {
                                <div class="analysis-metrics">
                                    <h6>Grammar Metrics</h6>
                                    <div class="metrics-grid">
                                        <div class="metric-item">
                                            <div class="metric-value">@grammarAnalysis.TotalRules</div>
                                            <div class="metric-label">Total Rules</div>
                                        </div>
                                        <div class="metric-item">
                                            <div class="metric-value">@grammarAnalysis.TerminalRules</div>
                                            <div class="metric-label">Terminal Rules</div>
                                        </div>
                                        <div class="metric-item">
                                            <div class="metric-value">@grammarAnalysis.NonTerminalRules</div>
                                            <div class="metric-label">Non-Terminal Rules</div>
                                        </div>
                                        <div class="metric-item">
                                            <div class="metric-value">@grammarAnalysis.CyclomaticComplexity</div>
                                            <div class="metric-label">Complexity</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="analysis-warnings mt-3">
                                    <h6>Analysis Warnings</h6>
                                    @if (grammarAnalysis.Warnings.Any())
                                    {
                                        @foreach (var warning in grammarAnalysis.Warnings)
                                        {
                                            <div class="alert alert-warning alert-sm">
                                                <i class="bi bi-exclamation-triangle me-2"></i>
                                                <strong>@warning.Type:</strong> @warning.Message
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <div class="text-success">
                                            <i class="bi bi-check-circle me-2"></i>
                                            No warnings detected
                                        </div>
                                    }
                                </div>

                                <div class="analysis-suggestions mt-3">
                                    <h6>Optimization Suggestions</h6>
                                    @if (grammarAnalysis.Suggestions.Any())
                                    {
                                        @foreach (var suggestion in grammarAnalysis.Suggestions)
                                        {
                                            <div class="suggestion-item">
                                                <div class="suggestion-header">
                                                    <i class="bi bi-lightbulb text-warning me-2"></i>
                                                    <strong>@suggestion.Type</strong>
                                                </div>
                                                <div class="suggestion-description">@suggestion.Message</div>
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <div class="text-muted">
                                            <i class="bi bi-check-circle me-2"></i>
                                            Grammar is well-optimized
                                        </div>
                                    }
                                </div>
                            }
                            else
                            {
                                <div class="text-center text-muted">
                                    <i class="bi bi-graph-up fs-1"></i>
                                    <p>Parse grammar to see analysis</p>
                                </div>
                            }
                        </div>
                    }

                    <!-- Errors Tab -->
                    @if (activeTab == "errors")
                    {
                        <div class="grammar-errors">
                            <h6>Parsing Errors (@grammarErrors.Count)</h6>
                            @if (grammarErrors.Any())
                            {
                                <div class="errors-list">
                                    @foreach (var error in grammarErrors)
                                    {
                                        <div class="error-item" @onclick="() => GoToError(error)">
                                            <div class="error-header">
                                                <i class="bi bi-exclamation-triangle text-danger me-2"></i>
                                                <strong>Line @error.Line, Column @error.Column</strong>
                                            </div>
                                            <div class="error-message">@error.Message</div>
                                            <div class="error-context">
                                                <code>@error.Context</code>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                            else
                            {
                                <div class="text-center text-success">
                                    <i class="bi bi-check-circle fs-1"></i>
                                    <p>No errors found</p>
                                </div>
                            }
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.grammar-editor {
    height: calc(100vh - 120px);
    padding: 1rem;
}

.code-editor-container {
    display: flex;
    height: calc(100vh - 300px);
}

.editor-gutter {
    width: 60px;
    background-color: #f8f9fa;
    border-right: 1px solid #dee2e6;
    padding: 0.5rem 0;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.5;
    overflow: hidden;
}

.line-number {
    padding: 0 0.5rem;
    text-align: right;
    color: #6c757d;
    position: relative;
    height: 21px;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.line-number.error-line {
    background-color: #f8d7da;
}

.code-editor {
    flex: 1;
    border: none;
    resize: none;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    padding: 0.5rem;
    outline: none;
}

.code-editor.syntax-highlighted {
    background-color: #f8f9fa;
}

.code-editor-highlighted {
    position: absolute;
    width: 100%;
    height: 100%;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    padding: 0.5rem;
    background-color: #ffffff;
    border: none;
    white-space: pre-wrap;
    overflow: auto;
    pointer-events: none;
    z-index: 1;
}

.code-editor-overlay {
    position: relative;
    z-index: 2;
}

.completion-dropdown {
    position: absolute;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    min-width: 300px;
}

.completion-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
}

.completion-item:hover,
.completion-item.selected {
    background-color: #e3f2fd;
}

.completion-item i {
    margin-right: 8px;
    width: 16px;
    color: #666;
}

.completion-label {
    font-weight: 500;
    margin-right: auto;
}

.completion-detail {
    font-size: 0.85em;
    color: #666;
    margin-left: 8px;
}

/* Syntax Highlighting Styles */
.keyword { color: #0000ff; font-weight: bold; }
.string { color: #a31515; }
.comment { color: #008000; font-style: italic; }
.number { color: #098658; }
.type { color: #2b91af; }
.operator { color: #000000; font-weight: bold; }
.identifier { color: #000000; }
.text { color: #000000; }

.editor-status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.25rem 0.5rem;
    background-color: #f8f9fa;
    border-top: 1px solid #dee2e6;
    font-size: 0.875rem;
}

.status-item {
    margin-right: 1rem;
}

.status-item:last-child {
    margin-right: 0;
}

.rules-list {
    max-height: calc(100vh - 400px);
    overflow-y: auto;
}

.rule-item {
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.rule-item:hover {
    background-color: #f8f9fa;
    border-color: #adb5bd;
}

.rule-item.selected {
    background-color: #e3f2fd;
    border-color: #2196f3;
}

.rule-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.25rem;
}

.rule-preview {
    font-family: monospace;
    font-size: 0.875rem;
    color: #6c757d;
    margin-bottom: 0.25rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.rule-stats {
    font-size: 0.75rem;
}

.metrics-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1rem;
}

.metric-item {
    text-align: center;
    padding: 0.75rem;
    background-color: #f8f9fa;
    border-radius: 0.375rem;
}

.metric-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: #495057;
}

.metric-label {
    font-size: 0.875rem;
    color: #6c757d;
}

.alert-sm {
    padding: 0.5rem;
    margin-bottom: 0.5rem;
}

.suggestion-item {
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    background-color: #f8f9fa;
    border-radius: 0.375rem;
    border-left: 3px solid #ffc107;
}

.suggestion-header {
    display: flex;
    align-items: center;
    margin-bottom: 0.25rem;
}

.suggestion-description {
    font-size: 0.875rem;
    color: #6c757d;
}

.error-item {
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    border: 1px solid #dee2e6;
    border-left: 3px solid #dc3545;
    border-radius: 0.375rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.error-item:hover {
    background-color: #f8f9fa;
}

.error-header {
    display: flex;
    align-items: center;
    margin-bottom: 0.25rem;
}

.error-message {
    margin-bottom: 0.25rem;
    color: #495057;
}

.error-context {
    font-size: 0.875rem;
    background-color: #f8f9fa;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
}
</style>

@code {
    private string grammarName = "MyGrammar";
    private string grammarType = "combined";
    private string grammarVersion = "1.0.0";
    private bool enableSyntaxHighlighting = true;
    private bool hasUnsavedChanges = false;
    private bool isParsingGrammar = false;
    private bool isGrammarValid = false;
    private bool isAnalyzingShifts = false;
    
    // Enhanced syntax highlighting and completion
    private string highlightedContent = "";
    private bool showCompletionDropdown = false;
    private List<CompletionItem> completionItems = new();
    private CompletionItem? selectedCompletionItem;
    private int completionDropdownTop = 0;
    private int completionDropdownLeft = 0;
    private int currentCursorPosition = 0;
    
    private int currentLine = 1;
    private int currentColumn = 1;
    
    private string activeTab = "rules";
    private string? selectedRuleName;

    private ElementReference codeEditorElement;

    private string grammarContent = @"grammar MyGrammar;

// Parser rules
compilationUnit: statement* EOF;

statement: 
    | variableDeclaration ';'
    | assignment ';'
    | ifStatement
    | whileStatement
    | blockStatement
    ;

variableDeclaration: 'var' IDENTIFIER ('=' expression)?;
assignment: IDENTIFIER '=' expression;
ifStatement: 'if' '(' expression ')' statement ('else' statement)?;
whileStatement: 'while' '(' expression ')' statement;
blockStatement: '{' statement* '}';

expression:
    | expression ('*' | '/') expression
    | expression ('+' | '-') expression
    | '(' expression ')'
    | IDENTIFIER
    | NUMBER
    ;

// Lexer rules
IDENTIFIER: [a-zA-Z_][a-zA-Z0-9_]*;
NUMBER: [0-9]+;
WS: [ \t\r\n]+ -> skip;";

    private List<GrammarRule> grammarRules = new();
    private List<GrammarError> grammarErrors = new();
    private GrammarAnalysis? grammarAnalysis;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ParseGrammar();
        }
    }

    private async Task OnGrammarContentChanged(ChangeEventArgs e)
    {
        grammarContent = e.Value?.ToString() ?? "";
        hasUnsavedChanges = true;
        
        // Update cursor position (simplified)
        await UpdateCursorPosition();
        
        // Clear previous parsing results
        isGrammarValid = false;
        grammarErrors.Clear();
        
        // Update syntax highlighting if enabled
        if (enableSyntaxHighlighting)
        {
            await UpdateSyntaxHighlighting();
        }
        
        // Trigger real-time validation after a short delay
        _ = DelayedValidation();
        
        StateHasChanged();
    }

    private void OnGrammarMetadataChanged(ChangeEventArgs e)
    {
        hasUnsavedChanges = true;
        StateHasChanged();
    }

    private async Task UpdateCursorPosition()
    {
        try
        {
            // Get cursor position from JavaScript
            var position = await JSRuntime.InvokeAsync<int>("getCursorPosition", codeEditorElement);
            currentCursorPosition = position;
            
            // Calculate line and column
            var textBeforeCursor = grammarContent.Take(position);
            currentLine = textBeforeCursor.Count(c => c == '\n') + 1;
            var lastNewline = grammarContent.LastIndexOf('\n', Math.Max(0, position - 1));
            currentColumn = position - lastNewline;
        }
        catch
        {
            // Fallback to simple calculation
            currentLine = grammarContent.Split('\n').Length;
            currentColumn = grammarContent.Split('\n').LastOrDefault()?.Length ?? 0;
        }
    }
    
    private async Task UpdateSyntaxHighlighting()
    {
        try
        {
            var grammarName = DetermineGrammarType();
            highlightedContent = await SyntaxService.GetHighlightedHtmlAsync(grammarContent, grammarName);
        }
        catch (Exception)
        {
            // Fallback to plain text if highlighting fails
            highlightedContent = System.Web.HttpUtility.HtmlEncode(grammarContent);
        }
    }
    
    private async Task ShowCodeCompletions()
    {
        try
        {
            if (string.IsNullOrEmpty(grammarContent)) return;
            
            var grammarName = DetermineGrammarType();
            var result = await CompletionService.GetCompletionsAsync(
                grammarContent, 
                currentCursorPosition, 
                grammarName);
            
            if (result.IsSuccess && result.Items.Any())
            {
                completionItems = result.Items;
                selectedCompletionItem = completionItems.FirstOrDefault();
                
                // Calculate dropdown position (simplified)
                completionDropdownTop = currentLine * 20; // Approximate line height
                completionDropdownLeft = currentColumn * 8; // Approximate character width
                
                showCompletionDropdown = true;
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Silently fail completion
        }
    }
    
    private async Task HandleTabCompletion()
    {
        if (showCompletionDropdown && selectedCompletionItem != null)
        {
            await InsertCompletion(selectedCompletionItem);
        }
    }
    
    private void NavigateCompletionItems(int direction)
    {
        if (!completionItems.Any()) return;
        
        var currentIndex = selectedCompletionItem != null 
            ? completionItems.IndexOf(selectedCompletionItem) 
            : -1;
        
        var newIndex = Math.Max(0, Math.Min(completionItems.Count - 1, currentIndex + direction));
        selectedCompletionItem = completionItems[newIndex];
        
        StateHasChanged();
    }
    
    private async Task InsertCompletion(CompletionItem item)
    {
        try
        {
            // Calculate insertion position
            var wordStart = Math.Max(0, currentCursorPosition - (selectedCompletionItem?.Label?.Length ?? 0));
            
            // Replace current word with completion
            var beforeWord = grammarContent[..wordStart];
            var afterCursor = grammarContent[currentCursorPosition..];
            
            grammarContent = beforeWord + item.InsertText + afterCursor;
            
            // Update cursor position
            currentCursorPosition = wordStart + item.InsertText.Length;
            
            showCompletionDropdown = false;
            hasUnsavedChanges = true;
            
            // Update highlighting
            if (enableSyntaxHighlighting)
            {
                await UpdateSyntaxHighlighting();
            }
            
            StateHasChanged();
            
            // Focus back to editor
            await JSRuntime.InvokeVoidAsync("focusElement", codeEditorElement);
        }
        catch (Exception)
        {
            // Silently handle errors
        }
    }
    
    private async Task FocusEditor()
    {
        await JSRuntime.InvokeVoidAsync("focusElement", codeEditorElement);
    }
    
    private string DetermineGrammarType()
    {
        // Determine grammar type based on current grammar type selection or content analysis
        return grammarType switch
        {
            "lexer" => "AntlrLexer",
            "parser" => "AntlrParser", 
            "combined" => "AntlrCombined",
            _ => "AntlrGeneric"
        };
    }
    
    private string GetCompletionIcon(CompletionItemKind kind)
    {
        return kind switch
        {
            CompletionItemKind.Keyword => "bi-key",
            CompletionItemKind.Method => "bi-gear",
            CompletionItemKind.Property => "bi-diagram3",
            CompletionItemKind.Class => "bi-box",
            CompletionItemKind.Interface => "bi-diamond",
            CompletionItemKind.Variable => "bi-code",
            _ => "bi-text-left"
        };
    }
    
    private async Task ValidateGrammarRealTime()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(grammarContent)) return;
            
            var grammarName = DetermineGrammarType();
            var errors = await SyntaxService.ValidateSyntaxAsync(grammarContent, grammarName);
            
            // Convert to grammar errors
            grammarErrors.Clear();
            grammarErrors.AddRange(errors.Select(e => new GrammarError
            {
                Line = e.Line,
                Column = e.Column,
                Message = e.Message,
                Context = "Real-time validation"
            }));
        }
        catch
        {
            // Silently handle validation errors
        }
    }
    
    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Tab")
        {
            // Handle tab completion
            await HandleTabCompletion();
        }
        else if (e.Key == "." || e.Key == " " || char.IsLetter(e.Key.FirstOrDefault()))
        {
            // Trigger completion after a short delay
            await Task.Delay(100);
            await ShowCodeCompletions();
        }
        else if (e.Key == "Escape")
        {
            // Hide completion dropdown
            showCompletionDropdown = false;
            StateHasChanged();
        }
        else if (e.Key == "ArrowDown" && showCompletionDropdown)
        {
            // Navigate completion items
            NavigateCompletionItems(1);
        }
        else if (e.Key == "ArrowUp" && showCompletionDropdown)
        {
            // Navigate completion items
            NavigateCompletionItems(-1);
        }
        else if (e.Key == "Enter" && showCompletionDropdown && selectedCompletionItem != null)
        {
            // Insert selected completion
            await InsertCompletion(selectedCompletionItem);
        }
    }

    private void NewGrammar()
    {
        if (hasUnsavedChanges)
        {
            // In real implementation, show confirmation dialog
        }
        
        grammarName = "NewGrammar";
        grammarContent = "grammar NewGrammar;\n\n// Add your rules here\n";
        grammarRules.Clear();
        grammarErrors.Clear();
        grammarAnalysis = null;
        hasUnsavedChanges = false;
        isGrammarValid = false;
        
        StateHasChanged();
    }

    private async Task OpenGrammar()
    {
        // In real implementation, this would open a file dialog
        await Task.Delay(100);
    }

    private async Task SaveGrammar()
    {
        // In real implementation, this would save to file
        await Task.Delay(200);
        hasUnsavedChanges = false;
        StateHasChanged();
    }

    private async Task ParseGrammar()
    {
        if (string.IsNullOrWhiteSpace(grammarContent))
            return;

        isParsingGrammar = true;
        grammarErrors.Clear();
        grammarRules.Clear();
        
        StateHasChanged();

        try
        {
            // Simulate grammar parsing
            await Task.Delay(500);
            
            // Extract rules (simplified parsing)
            var lines = grammarContent.Split('\n');
            
            foreach (var line in lines)
            {
                var trimmed = line.Trim();
                if (string.IsNullOrEmpty(trimmed) || trimmed.StartsWith("//"))
                    continue;
                    
                if (trimmed.Contains(':'))
                {
                    var parts = trimmed.Split(':', 2);
                    if (parts.Length == 2)
                    {
                        var ruleName = parts[0].Trim();
                        var ruleBody = parts[1].Trim().TrimEnd(';');
                        
                        grammarRules.Add(new GrammarRule
                        {
                            Name = ruleName,
                            Definition = ruleBody.Length > 50 ? ruleBody[..50] + "..." : ruleBody,
                            Type = char.IsUpper(ruleName[0]) ? "Lexer" : "Parser",
                            References = Random.Shared.Next(0, 10),
                            Alternatives = ruleBody.Split('|').Length
                        });
                    }
                }
            }

            // Generate analysis
            grammarAnalysis = new GrammarAnalysis
            {
                TotalRules = grammarRules.Count,
                TerminalRules = grammarRules.Count(r => r.Type == "Lexer"),
                NonTerminalRules = grammarRules.Count(r => r.Type == "Parser"),
                CyclomaticComplexity = grammarRules.Sum(r => r.Alternatives),
                Warnings = new List<AnalysisWarning>
                {
                    new() { Type = "Left Recursion", Message = "Rule 'expression' may have left recursion issues" }
                },
                Suggestions = new List<AnalysisSuggestion>
                {
                    new() { Type = "Rule Ordering", Message = "Consider reordering rules for better readability", Priority = "Medium", AutoFixAvailable = false }
                }
            };

            isGrammarValid = true;
        }
        catch (Exception ex)
        {
            grammarErrors.Add(new GrammarError
            {
                Line = 1,
                Column = 1,
                Message = ex.Message,
                Context = "Grammar parsing failed"
            });
        }
        finally
        {
            isParsingGrammar = false;
            StateHasChanged();
        }
    }

    private void ToggleSyntaxHighlighting()
    {
        StateHasChanged();
    }

    private void SetActiveTab(string tab)
    {
        activeTab = tab;
        StateHasChanged();
    }

    private void SelectRule(string ruleName)
    {
        selectedRuleName = ruleName;
        StateHasChanged();
    }

    private void AddNewRule()
    {
        // In real implementation, this would add a new rule template
        var newRuleName = $"newRule{grammarRules.Count + 1}";
        grammarContent += $"\n\n{newRuleName}: /* define rule here */;";
        hasUnsavedChanges = true;
        StateHasChanged();
    }

    private async Task GoToError(GrammarError error)
    {
        // In real implementation, this would focus the editor and move cursor to error location
        await JSRuntime.InvokeVoidAsync("focusElement", codeEditorElement);
    }
    
    private void OpenMarketplace()
    {
        // Navigate to marketplace in a new tab/window or show marketplace modal
        NavigationManager.NavigateTo("/marketplace");
    }
    
    private async Task AnalyzeShifts()
    {
        if (string.IsNullOrWhiteSpace(grammarContent))
        {
            return;
        }
        
        isAnalyzingShifts = true;
        StateHasChanged();
        
        try
        {
            // Simulate shift detection analysis
            await Task.Delay(2000);
            
            // In real implementation, this would call the shift detection service
            // var shiftAnalysis = await _shiftDetectionService.AnalyzeShifts(grammarContent, grammarVersion);
            
            // For demo, add mock analysis results
            grammarAnalysis ??= new GrammarAnalysis();
            grammarAnalysis.Warnings.Add(new AnalysisWarning
            {
                Type = "LegacyPattern",
                Message = "Consider using modern nullable reference types syntax",
                Line = 15,
                Severity = "Medium"
            });
            
            grammarAnalysis.Suggestions.Add(new AnalysisSuggestion
            {
                Type = "Modernization",
                Message = "Upgrade to C# 11.0 features for better performance",
                Priority = "High",
                AutoFixAvailable = true
            });
            
            // Switch to analysis tab to show results
            activeTab = "analysis";
        }
        catch (Exception ex)
        {
            // Handle error
            Console.WriteLine($"Shift analysis error: {ex.Message}");
        }
        finally
        {
            isAnalyzingShifts = false;
            StateHasChanged();
        }
    }

    private async Task DelayedValidation()
    {
        try
        {
            await Task.Delay(500);
            await InvokeAsync(async () => 
            {
                await ValidateGrammarRealTime();
                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            // Log error but don't throw to avoid unhandled exceptions in fire-and-forget
            Console.WriteLine($"Delayed validation error: {ex.Message}");
        }
    }

    public class GrammarRule
    {
        public string Name { get; set; } = "";
        public string Definition { get; set; } = "";
        public string Type { get; set; } = "";
        public int References { get; set; }
        public int Alternatives { get; set; }
    }

    public class GrammarError
    {
        public int Line { get; set; }
        public int Column { get; set; }
        public string Message { get; set; } = "";
        public string Context { get; set; } = "";
    }

    public class GrammarAnalysis
    {
        public int TotalRules { get; set; }
        public int TerminalRules { get; set; }
        public int NonTerminalRules { get; set; }
        public int CyclomaticComplexity { get; set; }
        public List<AnalysisWarning> Warnings { get; set; } = new();
        public List<AnalysisSuggestion> Suggestions { get; set; } = new();
    }

    public class AnalysisWarning
    {
        public string Type { get; set; } = "";
        public string Message { get; set; } = "";
        public int Line { get; set; }
        public string Severity { get; set; } = "";
    }

    public class AnalysisSuggestion
    {
        public string Type { get; set; } = "";
        public string Message { get; set; } = "";
        public string Priority { get; set; } = "";
        public bool AutoFixAvailable { get; set; }
    }
}